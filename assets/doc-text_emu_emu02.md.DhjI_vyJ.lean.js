import{_ as a,c as t,a2 as o,o as e}from"./chunks/framework.3VuPyQdv.js";const p="/docs-demo/emuImage/image-20230918205946367.png",r="/docs-demo/emuImage/image-20230913201322082.png",d="/docs-demo/emuImage/image-20230913203235933.png",h="/docs-demo/emuImage/image-20230913203418981.png",s="/docs-demo/emuImage/image-20230913205424986.png",n="/docs-demo/emuImage/%E5%88%86%E6%97%B6%E5%A4%8D%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86.png",u="/docs-demo/emuImage/image-20230918191948471.png",c="/docs-demo/emuImage/image-20230914213503013.png",i="/docs-demo/emuImage/%E5%A5%87%E5%81%B6%E5%9C%B0%E5%9D%80.png",m="/docs-demo/emuImage/image-20230918202145106.png",H=JSON.parse('{"title":"流水线技术","description":"","frontmatter":{},"headers":[],"relativePath":"doc-text/emu/emu02.md","filePath":"doc-text/emu/emu02.md","lastUpdated":1744383023000}'),P={name:"doc-text/emu/emu02.md"};function U(I,l,B,C,b,D){return e(),t("div",null,l[0]||(l[0]=[o('<h1 id="流水线技术" tabindex="-1">流水线技术 <a class="header-anchor" href="#流水线技术" aria-label="Permalink to &quot;流水线技术&quot;">​</a></h1><p>8086采用流水线技术、计算机中的流水线是把一个重复的过程分解为若干个子过程，每个子过程与其他子过程并行进行流水线技术是一种时间并行技术。</p><h2 id="存储器也分奇偶、io也区分奇偶" tabindex="-1">存储器也分奇偶、IO也区分奇偶 <a class="header-anchor" href="#存储器也分奇偶、io也区分奇偶" aria-label="Permalink to &quot;存储器也分奇偶、IO也区分奇偶&quot;">​</a></h2><h2 id="_8086-8088微处理器概述" tabindex="-1">8086/8088微处理器概述 <a class="header-anchor" href="#_8086-8088微处理器概述" aria-label="Permalink to &quot;8086/8088微处理器概述&quot;">​</a></h2><ol><li>8086 CPU是Intel系列的16位微处理器，它有16位数据总线和20位地址总线，所以可寻址的地址空间是 <ol><li>2的20次方＝1MB</li></ol></li><li>而8088只有8根数据总线</li><li>8086CPU是准16位微处理器，8086和8088的区别是： <ol><li>8088是对外的数据总线只有8位，但是它可以处理16位数据</li><li>8086是16位微处理器</li><li>8088是准16位微处理器</li><li>指令队列寄存器 <ol><li>8086 CPU 6个字节</li><li>8088 CPU 4个字节</li></ol></li><li>8086有 BHE 非</li><li>而 8088 没有 BHE非</li><li>8086是 M/IO 非</li><li>8088是 IO/M 非</li></ol></li></ol><h3 id="_8086cpu的编程结构" tabindex="-1">8086CPU的编程结构 <a class="header-anchor" href="#_8086cpu的编程结构" aria-label="Permalink to &quot;8086CPU的编程结构&quot;">​</a></h3><p><a href="https://www.processon.com/mindmap/650add5063e8b53d2989f6dc" target="_blank" rel="noreferrer">CPU的组成部分(特别详细)-思维导图</a></p><p>从程序员的角度来看，8086CPU分为两部分：执行部件(EU)、总线接口部件(BIU)EU 负责执行所有指令，向 BIU 提供数据和地址</p><h4 id="执行过程" tabindex="-1">执行过程： <a class="header-anchor" href="#执行过程" aria-label="Permalink to &quot;执行过程：&quot;">​</a></h4><p>EU 负责执行所有指令，向 BIU 提供数据和地址，操纵通用寄存器和标志寄存器。除了几个控制引脚外，EU 完全与“外部世界”隔绝。BIU 负责执行所有外部总线周期，由段寄存器 和 通用寄存器（指令指针寄存器 和 指令代码队列）组成。BIU 在其专用累加器中结合段和偏移值来获得20位地址，BIU 负责根据 EU 要求读取数据，或者把 EU 执行后算术运算器中寄存器上的数据传输出去，另外 BIU 还负责预先读取要执行的指令缓存到指令代码队列供 EU 使用。</p><p>当EU准备好执行一条指令时，它从BIU的指令队列中获取指令目标码字节，然后执行该指令。如果EU准备取指令字节时队列为空，则EU等待取指令字节。在指令执行的过程中，如果内存位置或I/O端口必须被访问，EU请求BIU执行所需的总线周期。</p><p>CPU的两个处理部分是独立运行的。在8086 CPU中，当6字节指令队列的两个或两个以上字节为空时，EU不需要BIU执行总线周期，BIU执行指令获取周期来重新填充队列。在8088 CPU中，当4字节指令队列中的一个字节为空时，BIU执行一个指令获取周期。注意，8086 CPU，因为它有一个16位的数据总线，可以在一个总线周期访问两个指令目标码字节，而8088 CPU，因为它有一个8位的数据总线，每个总线周期访问一个指令目标码字节。如果 EU 在 BIU 处于指令获取总线周期的过程中发出总线访问请求，那么 BIU 在执行 EU 的请求之前完成该周期。</p><p>CPU：</p><img src="'+p+'" alt="image-20230918205946367" style="zoom:50%;"><h3 id="_1、执行部件-eu-分析指令、执行指令" tabindex="-1">1、执行部件(EU：分析指令、执行指令) <a class="header-anchor" href="#_1、执行部件-eu-分析指令、执行指令" aria-label="Permalink to &quot;1、执行部件(EU：分析指令、执行指令)&quot;">​</a></h3><ol><li>功能：执行指令</li><li>组成： <ol><li>4个通用寄存器(都是可以用来存放数据)，即AX(累加器：专门用来存放数据)、BX(基址寄存器：间接寻址中用于存放基地址，默认在数据段)、CX(计数寄存器：循环存放在CX，移位指令存放在 CL)、DX(数据寄存器：存放高16位数，AX存放低16位，AX放不下，可以使用DX存放，可以存外设地址) <ol><li>4个专用寄存器，即(暂存数据)(一定长度的二进制位) <ol><li>基址指针寄存器 BP(base pointer)</li><li>堆栈指针寄存器 SP(stack pointer)</li><li>源变址寄存器 SI (source index)</li><li>目的变址寄存器 DI (destination index)</li></ol></li></ol></li><li>标志寄存器 FR(FLAGS)</li><li>算术逻辑单元 ALU (arithmetic logic unit)</li><li>内部控制逻辑</li><li>暂存器</li><li>EU控制器</li></ol></li></ol><h4 id="内部寄存器组" tabindex="-1">内部寄存器组 <a class="header-anchor" href="#内部寄存器组" aria-label="Permalink to &quot;内部寄存器组&quot;">​</a></h4><p>8个16位通用寄存器</p><ol><li>数据寄存器(AX、BX、CX、DX) 4个通用</li><li>指针和变址寄存器(SP、BP、SI、DI) 4个专用 <ol><li>数据寄存器：可用来存放16位的数据或地址。又可分为8个8位寄存器即： <ol><li>​ AX ——&gt; AH，AL AX(16位) 分为 AH(高八位) AL(低八位)</li><li>​ BX ——&gt; BH，BL BX(16位) 分为 BH(高八位) BL(低八位)</li><li>​ CX ——&gt; CH，CL CX(16位) 分为 CH(高八位) CL(低八位)</li><li>​ DX ——&gt; DH，DL DX(16位) 分为 DH(高八位) DL(低八位)</li><li>注意： <ol><li>8位寄存器只能存放数据而不能存放地址</li><li>8086中只有AX、BX、CX、DX，可以被分为高八位，低八位。其他不能被分</li></ol></li></ol></li></ol></li></ol><h4 id="数据寄存器特有的习惯用法" tabindex="-1">数据寄存器特有的习惯用法: <a class="header-anchor" href="#数据寄存器特有的习惯用法" aria-label="Permalink to &quot;数据寄存器特有的习惯用法:&quot;">​</a></h4><ol><li>AX：累加器。所有I/O指令都通过AX或AL与接口传送信息，中间运算结果也多放于AX中。</li><li>BX：基址寄存器。在间接寻址中用于存放基地址。</li><li>CX：计数寄存器。可以用作数据寄存器，在字符串操作、循环操作和移位操作时用作计数器，存放计数值。</li><li>DX：数据寄存器。在间接寻址的I/O指令中存放I/O端口地址；在32位乘除法运算时，存放高16位数。</li></ol><h4 id="指针和变址寄存器" tabindex="-1">指针和变址寄存器 <a class="header-anchor" href="#指针和变址寄存器" aria-label="Permalink to &quot;指针和变址寄存器&quot;">​</a></h4><ol><li><p>说明：</p><p>4个16位寄存器，主要用来存放操作数的偏移地址（即操作数的段内地址）。</p></li><li><p>SP：堆栈指针寄存器，在堆栈操作中存放栈顶的偏移地址。</p></li><li><p>BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址，还用作堆栈区的基地址寄存器</p><p>注意BX与BP在应用上的区别:</p><ol><li>作为通用寄存器，二者均可用于存放数据</li><li>作为基址寄存器，用BX表示所寻找的数据在数据段； 用BP则表示数据在堆栈段</li></ol></li><li><p>SI：源变址寄存器，主要用于存放地址，在字符串操作中存放源操作数的偏移地址。</p></li><li><p>DI：目的变址寄存器，主要用于存放地址，在字符串操作中存放目的操作数的偏移地址。</p><p>变址寄存器常用于指令的间接寻址或变址寻址。</p><p>在串操作中变址寄存器内存放的地址在数据传送完成后，具有自动修改的功能。例如，传送1字节数据后地址自动加1，为下次传送做好准备，变址寄存器因此得名。</p></li></ol><h4 id="_2、算术逻辑单元-alu-及标志寄存器-fr或flags" tabindex="-1">2、算术逻辑单元（ALU）及标志寄存器（FR或FLAGS） <a class="header-anchor" href="#_2、算术逻辑单元-alu-及标志寄存器-fr或flags" aria-label="Permalink to &quot;2、算术逻辑单元（ALU）及标志寄存器（FR或FLAGS）&quot;">​</a></h4><p>① 算术逻辑运算单元ALU：</p><p>​ 可完成16位或8位的算术逻辑运算，运算结果通过内部总线送到通用寄存器，或者送往BIU的内部寄存器中，等待写入存储器。ALU运算后的结果特征（有无进位，溢出等）置入标志寄存器FLAGS中保存。</p><p>② 标志寄存器FLAGS：</p><p>​ 16位寄存器，用来存放运算结果的特征和控制标志。</p><img src="'+r+'" alt="image-20230913201322082" style="zoom:80%;"><img src="'+d+'" alt="image-20230913203235933" style="zoom:80%;"><p>根据功能，8086的标志可以分为两类：</p><ol><li><p>状态标志——6个，用来表示运算结果的特征。</p><p>包括CF、PF、AF、ZF、SF和OF</p></li><li><p>控制标志——3个，用来控制CPU的操作。</p><p>包括IF、DF和TF。</p></li></ol><p>8位二进制</p><p>​ 00H——&gt;7FH ≥ 0</p><p>​ 80H ——&gt;0FFH ＜ 0 负数 因为80H——&gt;0FFH最高位是1</p><p>如何判定溢出：</p><ol><li>负+负=正 溢出</li><li>负-负=&gt; 无溢出</li><li>正-正=&gt; 无溢出</li><li>正+正=&gt; 溢出</li><li>负+负=&gt; 溢出</li><li>负-正=&gt; 溢出</li><li>正-负=&gt; 溢出</li></ol><p>OF：同进、同不进 OF=0，不同 0F=1</p><h3 id="_2、biu总线接口部件-程序存储、取指令" tabindex="-1">2、BIU总线接口部件(程序存储、取指令) <a class="header-anchor" href="#_2、biu总线接口部件-程序存储、取指令" aria-label="Permalink to &quot;2、BIU总线接口部件(程序存储、取指令)&quot;">​</a></h3><p>总线接口部件按功能分3种：</p><ol><li>AB 地址总线 (Address Bus)</li><li>DB 数据总线 (Data Bus)</li><li>CB 控制总线 (control Bus)</li></ol><p>总线接口部件(BIU)：实现了CPU和取指令外界交换数据</p><ol><li>功能： <ol><li>形成访问存储器的物理地址</li><li>访问存储器取得指令并暂存到指令队列中等待执行</li><li>访问存储器或I/O端口以读取操作数参与EU运算或存放运算结果等</li></ol></li><li>组成： <ol><li>4个段地址寄存器(CS(代码段)、DS(数据段)、ES(附加段)、SS(堆栈段))</li><li>16位的指针寄存器 IP (Instruction pointer)</li><li>20位的地址加法器</li><li>6字节的指令队列缓冲器(预取指令)</li><li>总线控制逻辑</li></ol></li></ol><h5 id="地址加法器" tabindex="-1"><strong>地址加法器</strong> <a class="header-anchor" href="#地址加法器" aria-label="Permalink to &quot;**地址加法器**&quot;">​</a></h5><ol><li>功能：完成逻辑地址向物理地址的变换。</li><li>物理地址：访问存储器的实际地址，用20位二进制表示</li><li>方法：物理地址＝段基址×16 （即左移4位）+ 偏移地址</li><li>注意： <ol><li>一个存储单元的物理地址是唯一的，而它对应的逻辑地址是不唯一的。</li></ol></li></ol><h5 id="指令指针寄存器ip——-16位" tabindex="-1">指令指针寄存器IP—— 16位 <a class="header-anchor" href="#指令指针寄存器ip——-16位" aria-label="Permalink to &quot;指令指针寄存器IP—— 16位&quot;">​</a></h5><p>功能：用来存放将要执行的下一条指令在代码段中的偏移地址。在程序运行过程中，BIU自动修改IP中的内容，使它始终指向将要执行的下一条指令。</p><p>注意：程序不能直接访问IP，但是可通过某些指令修改IP的内容。例如, 执行转移指令时，会将转移的目标地址送入IP中，以实现程序的转移。</p><h5 id="指令队列缓冲器——6字节" tabindex="-1">指令队列缓冲器——6字节 <a class="header-anchor" href="#指令队列缓冲器——6字节" aria-label="Permalink to &quot;指令队列缓冲器——6字节&quot;">​</a></h5><p>BIU从存储器中读出指令送入6字节的指令队列。一旦指令队列中空出2个字节，BIU将自动进行读指令的操作以填满指令队列。只要收到EU送来的操作数地址，BIU将立即形成这个操作数的物理地址，完成读/写操作。遇到转移类指令，BIU将指令队列中剩余的指令作废，重新从存储器新的地址单元中取指令并送入指令队列。一般情况下应保证指令队列中填满指令，使得EU可以不断地得到等待执行的指令。</p><h5 id="总线控制逻辑" tabindex="-1">总线控制逻辑 <a class="header-anchor" href="#总线控制逻辑" aria-label="Permalink to &quot;总线控制逻辑&quot;">​</a></h5><p>是将CPU的内部总线与CPU引脚所连接的外部总线相连，是CPU与外部交换信息（数据、地址、状态、控制信息）的必经之路，包括16条数据线、20条地址线和若干条控制信号线。</p><h3 id="eu和biu的寄存器总结" tabindex="-1">EU和BIU的寄存器总结 <a class="header-anchor" href="#eu和biu的寄存器总结" aria-label="Permalink to &quot;EU和BIU的寄存器总结&quot;">​</a></h3><p>8086分为14个寄存器：8个通用寄存器、4个段寄存器、2个控制寄存器</p><ul><li>8个通用寄存器：AX(累加器)、BX(基址寄存器)、CX(计数寄存器)、DX(数据寄存器)、SP(堆栈指针寄存器)、BP（基址指针寄存器）、SI(源变址寄存器)、DI(目的变址寄存器 )</li><li>4个段寄存器：CS(代码段寄存器)、DS(数据寄存器)、ES(附加段寄存器)、SS(堆栈段寄存器)</li><li>2个控制寄存器：IP(指针寄存器)专用、FR <ul><li>FR又分为：SF(零标志位)、OF(溢出标志)、PF(奇偶标志)、AF(半借位标志)、CF(进位标志)、ZF(零标志)、IF(单步中断)、DF(方向标志)、TF(符号标志)</li></ul></li></ul><h4 id="段地址寄存器-cs、ds、ss、es" tabindex="-1">段地址寄存器(CS、DS、SS、ES) <a class="header-anchor" href="#段地址寄存器-cs、ds、ss、es" aria-label="Permalink to &quot;段地址寄存器(CS、DS、SS、ES)&quot;">​</a></h4><p>​ <strong>存储器的分段</strong></p><p>​ 8086可寻址的存储空间为1MB，有20位的地址线，而内部的寄存器是16位，只能寻址64KB。所以8086/8088系统采用了地址分段的方法，将1MB存储空间分成若干块，称为“逻辑段”，每个逻辑容量≤64KB，存放一种类型的数据或程序。因此1MB的存储空间可分成16个逻辑段(0~15)。在段内寻址仍采用传统的16位地址寻址的方法。剩下四位左移了</p><p>​ 如何分成16段</p><p>​ 2的20次方 = 1MB = 2的16次方=64KB</p><p>​ 所以2的20次方-2的16次方=2的4次方=16段</p><img src="'+h+'" alt="image-20230913203418981" style="zoom:80%;"><p>8086只有20位地址，所以</p><p>​ 20位地址(物理地址)：分成高16位(段地址)和低16位(偏移地址)</p><p>​ 段起始是16的整数倍，写成16进制最低位一位为0(省略)</p><p>例如：</p><p>​ ABCDH =》 ABCD0H 0省略，0省略就是段起始地址</p><p>偏移地址公式</p><p>​ 20位地址 - 段起始 = 偏移地址</p><p>​ 例如：</p><p>​ 20位地址是 ABCD5H ，段起始地址是 ABCD0H(占高16位)，那么偏移地址(低16位)就是 ABCD5H - ABCD0H = 0005H(只能是16位，因为一个数占2位)</p><p>段起始地址公式</p><p>​ 段地址末尾 +0 ，类似于段地址 ×16</p><p>​ 例如：</p><p>​ 段起始地址是 ABCDH ，那么段地址是 ABCD0H</p><p>物理地址公式</p><p>​ 段地址 × 16 + 偏移地址 = 物理地址</p><p>20位物理地址是唯一的，他的取值范围是从 000000H ~ FFFFFFH</p><p>逻辑地址、段地址、偏移地址不唯一</p><p>​ 逻辑地址 = 段地址 : 偏移地址</p><p>​ 例如：</p><p>​ 物理地址 23000H</p><p>​ 1、段地址 2000H × 16 = 2000H 偏移地址3000H</p><p>​ 2、段地址 2300H × 16 = 23000H 偏移地址0000H</p><p>偏移地址16位最大</p><ol><li>最大 FFFFH (16个1)</li><li>最小 0000H (16个0)</li></ol><p>段地址确定</p><p>​ 对应偏移地址最大末单元</p><p>​ 对应偏移地址最小起始单元</p><p>​ 例如：</p><p>​ 段地址确定 1000H，根据公式 段地址×16+偏移地址</p><p>​ 最小 10000H 起始</p><p>​ 最大 1FFFFH 末</p><p>段地址×16+偏移地址+大 = 最大物理地址(对应首地址)</p><p>段地址×16+偏移地址+小 = 最小物理地址(对应末地址)</p><h5 id="段最大最小值" tabindex="-1">段最大最小值 <a class="header-anchor" href="#段最大最小值" aria-label="Permalink to &quot;段最大最小值&quot;">​</a></h5><p>​ 如果段有重叠最大值是16B</p><p>​ 例如：</p><p>​ 30000H ~ 3FFFFH</p><p>​ 3001H ~ 4000FH</p><p>​ 这个段有重叠就是16B</p><p>​ 那么段没有重叠段就有64KB，段最大是64KB，最小16B</p><p>段可分为：代码段、数据段、附加段、堆栈段用于存放段基址有 4个16位段寄存器，代码段寄存器CS，数据段寄存器DS，附加段寄存器ES和堆栈段寄存器SS。</p><p><strong>代码段</strong>：存放程序代码，程序代码超过64K时，需要分成几个段存放。CS中存放的是现在正在执行的程序段的段基址。</p><p><strong>数据段</strong>：用于存放当前使用的数据。需要第二个数据段时可以使用附加段。</p><p><strong>堆栈段</strong>：是内存中的一块存储区，用来存放专用数据。如调用子程序时的入口参数，返回地址等，这些数据都按照“后进先出”的规则进行存取。SS存放堆栈段的段基址，SP存放当前堆栈栈顶的偏移地址。数据进出堆栈要使用专门的堆栈操作指令，SP的值在执行堆栈操作指令时根据规则自动地进行修改。</p><img src="'+s+'" alt="image-20230913205424986" style="zoom:80%;"><h3 id="_8086三种周期" tabindex="-1">8086三种周期 <a class="header-anchor" href="#_8086三种周期" aria-label="Permalink to &quot;8086三种周期&quot;">​</a></h3><ol><li>时钟周期： <ol><li>时钟周期 = 主频分之一 赫兹 = 秒分之一</li><li>定义时钟周期是按字节拍有序地进行 <ol><li>时钟周期是CPU最小时间单位，大小等于主频的倒数</li></ol></li></ol></li><li>总线周期： <ol><li>CPU通过外部总线对存储器或I/O端进行一次读/写操作的过程称为总线周期 <ol><li>解释： <ol><li>为完成对存储器或I/O端口的一次访问，CPU需要先后发出存储器或I/O端口地址，发出读或写操作命令，后行数据的传输。以上的每一个操作都需要延续一个或几个时钟周期。所以，一个总线周期由若干个时钟周期(T)组成。</li></ol></li></ol></li></ol></li><li>指令周期： <ol><li>一条指令需要的时间，由若干个总线周期组成。</li><li>注意： <ol><li>若干个一般都是总线周期大于等于4个时钟周期</li></ol></li><li>先地址，后数据</li></ol></li></ol><h3 id="_8086cpu引脚的功能" tabindex="-1">8086CPU引脚的功能 <a class="header-anchor" href="#_8086cpu引脚的功能" aria-label="Permalink to &quot;8086CPU引脚的功能&quot;">​</a></h3><p>了解</p><p>​ 引脚是CPU和外界通信的现实途径</p><p>引脚按功能分为：16条数据线、20条地址线、控制引脚</p><p>引脚有40条，数据线占16条、地址线占20条。4根引脚还需要I/O等操作，所以采用分时复用</p><h3 id="分时复用" tabindex="-1">分时复用 <a class="header-anchor" href="#分时复用" aria-label="Permalink to &quot;分时复用&quot;">​</a></h3><ol><li>就是在同一根传输线上，在不同时间传送不同的信息。</li><li>8086/8088依靠分时复用技术，用40个引脚实现了众多数据、地址、控制信息的传送。</li><li>锁存器用来锁存地址，从而实现分时复用，锁存器不属于CPU内部。</li></ol><img src="'+n+'" style="zoom:80%;"><p>分时复用：同一根线(传输地址、数据，不能遗失，所有使用锁存器)，不同时间，传送不同信息。</p><p>分时复用的作用是：为了减少芯片引脚数量，对部分引脚采用分时复用的方式，构成了40条引脚的双列直插式封装分时复用</p><p>有一时刻，输出地址，使用锁存器把地址记录。交由锁存器帮CPU输出，从而替代CPU输出地址，然后这根线可以输出数据</p><h3 id="_8086cpu的引脚及功能" tabindex="-1">8086CPU的引脚及功能 <a class="header-anchor" href="#_8086cpu的引脚及功能" aria-label="Permalink to &quot;8086CPU的引脚及功能&quot;">​</a></h3><img src="'+u+'" alt="image-20230918191948471" style="zoom:80%;"><p>8086/8088CPU有两种不同的工作模式(最小模式和最大模式，8条引脚(24~31)在两种模式中具有不同的功能)。</p><p>引脚图括号中是最大模式下被重新定义的控制信号：</p><ul><li>输出：信号从CPU向外部传送</li><li>输入：信号从外部送入CPU</li><li>双向：信号有时从外部送入CPU，有时从CPU向外部传送</li><li>三太：除高电平、低电平两种状态之外，CPU内部还可以通过一个大的电阻，阻断内外信号的传送(高阻态)，CPU内部的状态与外部相互隔离，称为&quot;悬浮态&quot; 或 &quot;高阻态&quot;。</li></ul><h3 id="引脚" tabindex="-1">引脚 <a class="header-anchor" href="#引脚" aria-label="Permalink to &quot;引脚&quot;">​</a></h3><ol><li><p>GND(地) 和 VCC(电源)：供电使用（了解）</p></li><li><p>AD15~AD0(address data bus)：地址/数据复用引脚(双向、三态)</p></li><li><p>A19/S6~A16/S3(address/status)：地址复用引脚(A16到A19输出地址高四位)</p></li><li><p>BHE非/S7(状态)（Bus High Enable/Status）：高8位数据总线，允许引脚(区分奇偶地址)是否有用。</p></li><li><p>NMI（Non Maskable Interrupt Request）：非屏蔽中断引脚 (输入)</p></li><li><p>INTR（Interrupt Request）：可屏蔽中断请求信号(输入)，由外部触发，高电平有效</p><ol><li><p>中断控制信号分两种：</p><ol><li>不可屏蔽中断控制信号</li><li>可屏蔽中断控制信号</li></ol></li><li><p>INTR:可屏蔽中断请求信号</p></li><li><p>非INTA：中断响应信号，三态，低电平有效(反馈中断响应信号)</p></li></ol></li><li><p>RD非（Read）：读信号，三态输出，低电平有效，0表示读，1表示不读，表示当前CPU正在读存储器或I/O端口</p></li><li><p>CLK （Clock）时钟输入引脚（了解）</p><ol><li>8086要求时钟占空比为1/3，即一个周期中1/3为高电平、2/3为低电平。CPU的所有操作均是在时钟的同步下进行的。</li></ol></li><li><p>RESET（Reset）：复位引脚，输入，高电平有效</p><ol><li>8086要求复位信号至少维持4个时钟周期的高电平有效，以完成CPU内部寄存器的复位操作。</li><li>复位信号一出现，CPU立即结束当前的操作，进入复位操作，即将标志寄存器(FR)、IP、DS、SS、ES清0，指令队列清空，CS置为FFFFH。</li><li>当复位信号降为低电平后，CPU从CS:IP开始取出指令并执行它，即系统复位后执行的第一条指令的物理地址为FFFF0H。系统程序一般在物理地址单元放一条转移指令，转到引导程序的入口。</li></ol></li><li><p>READY（Ready）：准备好引脚，输入，高电平有效。</p></li><li><p>TEST（Test）：测试引脚，输入、低电平有效 (了解)</p></li><li><p>MN/MX非：最小/最大模式控制引脚，CPU输入信号</p><p>​ MN=+5V 非MX=0</p><p>该引脚接+5V，则8086工作在最小模式</p><p>该引脚接地(地=0)，则8086CPU工作在最大模式</p></li><li><p>DMA信号线</p><ol><li>HOLD：总线请求信号，输入，高电平有效，表示有其他设备向 CPU 请求使用总线</li><li>HLDA：总线请求响应，输出，高电平有效</li></ol></li></ol><p>DMA 传输不经过 CPU，在内存和 IO 设备之间直接传输数据的方法</p><p>引脚的不同状态实现了某些指令。</p><h3 id="四种状态-一共状态对应1个时钟周期" tabindex="-1">四种状态，一共状态对应1个时钟周期 <a class="header-anchor" href="#四种状态-一共状态对应1个时钟周期" aria-label="Permalink to &quot;四种状态，一共状态对应1个时钟周期&quot;">​</a></h3><img src="'+c+'" alt="image-20230914213503013" style="zoom:80%;"><ol><li>T1状态(送地址)： <ol><li>CPU向多路复用总线上发送地址信息(A19~A0)指出寻址的内存地址或I/O端口地址，还要送出地址锁存信号ALE(ALE信号，告诉锁存器要记住了，这个锁存器就记住了)。</li></ol></li><li>T2状态(做准备)： <ol><li>CPU从总线上撤销地址，使总线低16位呈现高阻(断开)状态，为数据传输做准备。</li></ol></li><li>T3状态(传输数据)： <ol><li>总线低16位上出现CPU需要的数据，如果外设和内存它的运行速度较慢，那么通过READY信息来查询是否需要插入等待状态(Tw)，若READY等于0，需要插入等待状态，直到READY等于1，结束等待状态后，跳过T3状态。</li><li>最基本的情况下1个总线周期 = 4个时钟周期(不含等待状态Tw)</li></ol></li><li>T4状态(总线周期结束)： <ol><li>若为总线周期则在T4前沿将数据读入CPU</li></ol></li><li>TI状态： <ol><li>总线周期空闲周期</li></ol></li></ol><h3 id="奇偶地址体" tabindex="-1">奇偶地址体 <a class="header-anchor" href="#奇偶地址体" aria-label="Permalink to &quot;奇偶地址体&quot;">​</a></h3><ol><li>8086走的是最小存储单元字节，那么每个地址对应的数据就是1字节</li><li>8086最小存储单元是字节，一共有20位地址线对应的就是1M，8086的寻找空间就是1MB</li><li>8086有16根数据总线，它一次可以交换2B的数据</li></ol><p>8086有16根DB(数据线)，而8088只有8根DB，那么8086怎么根8088传输数据？</p><ol><li>8088有8根数据总线，它一次可以交换1B的数据，为了解决一次性问题，把数字整数，分成两种数：奇数和偶数，那么设计者就把地址分成两种：奇地址和偶地址，然后它把所有奇地址的数据放在一个存储器里，把所有偶地址放在另一个存储器里，然后就可以一次性传输16bit的数据了</li></ol><p>二进制奇数最低位为1，偶数最低位为0</p><p>奇地址最低位为1，偶地址最低位为0</p><img src="'+i+'" style="zoom:80%;"><p>从而实现了一次性读写16位数据，如果要读写8位的话，我们先把16位一次性读进来，然后舍掉8位。</p><p>奇偶地址存储器分高低位</p><p>用地址线来接奇偶，数据线接对应的存储体。</p><h4 id="注意" tabindex="-1">注意： <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意：&quot;">​</a></h4><ol><li>地址总线区分奇偶地址，数据总线负责取走里面的数据。</li><li>偶地址只能走D0~D7(低8位)，奇地址只能走D8到D15(高8位)</li><li>取数一次性只能正向取数，就是先偶后奇，在偶在奇，取数</li></ol><h4 id="结论" tabindex="-1">结论： <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论：&quot;">​</a></h4><ol><li>从偶地址开始取1个字节，只需要一次总线周期</li><li>从奇地址开始取字节，只需要一次总线周期</li><li>从偶地址开始取2个字节，需要一个总线周期</li><li>从奇地址开始取2个字节，需要用2次总线</li><li>从偶地址开始的字，叫做规则字</li><li>从奇地址开始的字，叫做非规范字</li></ol><img src="'+i+'" style="zoom:60%;"><table tabindex="0"><thead><tr><th></th><th>D15~D8</th><th>D7~D0</th><th>总线次数</th></tr></thead><tbody><tr><td>只要1000H(偶)</td><td>×(1000H)</td><td>√(1000H)</td><td>1次</td></tr><tr><td>只要1000H(奇)</td><td>√(1000H)</td><td>×(1000H)</td><td>1次</td></tr><tr><td>要1001H和1002H(2字节)偶</td><td>√(1001H)</td><td>√(1001H)</td><td>一个周期</td></tr><tr><td>要1001H和1002H(2字节)</td><td>√(奇1001H)和×(偶1002H)</td><td>×(1000H)和√(偶1002H)</td><td>2次</td></tr></tbody></table><p>有控制D15~D8，还要D7到D0，要与不要的两个引脚</p><p>D15~D8(高位)：BHE非</p><p>D7~D0(低位)：A0(A0就是地址总线的A0)</p><p>BHE非(高8位数据是否有效)：上面的横表示0有效，低电平有效，BHE有效的时候它就是0，无效的时候它就是1</p><p>ALE：上面没有横就是1有效，0无效</p><p>A0=0(偶) A0=1(奇)</p><table tabindex="0"><thead><tr><th>高8位数据线是否有效</th><th>D15~D18(BHE非)</th><th>D7~D0(A0)</th></tr></thead><tbody><tr><td>偶(字节)</td><td>1(无效)</td><td>0</td></tr><tr><td>奇(字节)</td><td>0(有效)</td><td>1</td></tr><tr><td>(规则字)偶(字)</td><td>0(有效)</td><td>0</td></tr><tr><td>(非规则字)奇(字)</td><td>①奇字节 0 ②偶字节 1</td><td>1(奇字节) 0(偶字节)</td></tr></tbody></table><h4 id="如何判断奇偶地址" tabindex="-1">如何判断奇偶地址 <a class="header-anchor" href="#如何判断奇偶地址" aria-label="Permalink to &quot;如何判断奇偶地址&quot;">​</a></h4><ul><li>尾数是1、3、5、7 、9 、B、D、F 奇地址，剩余的全是偶地址 <ul><li>ABCDH 奇地址 789AH 偶地址</li></ul></li></ul><h3 id="_8086系统内存地址的一些专用区域" tabindex="-1">8086系统内存地址的一些专用区域 <a class="header-anchor" href="#_8086系统内存地址的一些专用区域" aria-label="Permalink to &quot;8086系统内存地址的一些专用区域&quot;">​</a></h3><p>0000~003FFH：1KB空间用于存放中断向量表，可存放256个中断服务程序的入口地址，每个地址占4个字节</p><p>FFFF0H：启动地址，一般用来存放一条无条件转移指令，转到系统初始化程序。</p><h3 id="_8086-i-o组织" tabindex="-1">8086 I/O组织 <a class="header-anchor" href="#_8086-i-o组织" aria-label="Permalink to &quot;8086 I/O组织&quot;">​</a></h3><p>8086系统有专用的输入(IN)、输出(OUT)指令，用于外设端口(即外设接口中的内部寄存器)的寻址。</p><p>I/O端口与内存分别独立编址。内存有20AB，所以寻址空间就是1MB。I/O端口(有16AB)使用16位地址A15~A0，I/O端口地址范围为0000H到FFFFH,可寻址空间为64KB。</p><h3 id="_8086的系统配置" tabindex="-1">8086的系统配置 <a class="header-anchor" href="#_8086的系统配置" aria-label="Permalink to &quot;8086的系统配置&quot;">​</a></h3><p>最大模式和最小模式的概念</p><ul><li>8086/8088 CPU为适应不同的应用环境。8086可工作于两种工作模式：最大模式和最小模式 <ul><li>最小模式：是指系统中只有一个8086/8088处理器，所有的总线控制信号都由8086/8088 CPU直接产生，构成系统所需的总线控制逻辑部件，最小模式因此得名。最小模式也称单处理模式。</li></ul></li></ul><p>最小模式下的系统控制信号</p><ul><li>M/IO非：存储器或I/O端口，访问选择信号，三态输出(指示访问存储器还是I/O端口) <ul><li>为高电平时，表示当前CPU正在访问存储器。</li><li>为低电平时，表示CPU当前正在访问I/O端口。</li></ul></li><li>RD非（Read）：读信号，三态输出，低电平有效，0表示读，1表示不读，表示当前CPU正在读存储器或I/O端口</li><li>WR非 (Write) : 写信号，为0写，为1不写，三太输出，低电平有效，表示当前CPU正在写存储器或 I/O 端口上。</li></ul><p>M/IO非 、 WR非、RD非 合起来决定系统中数据传输的方向。</p><p>ALE（Address Latch Enable） : 地址锁存允许信号，输出，高电平有效(地址出现的时候，ALE出现，地址消失的时候,ALE消失)</p><p>DEN非(Data Enable)：数据允许信号，三态输出，低电平有效(跟数据共存亡)</p><p>DT/R非 (Data Transmit/Receive)：数据发送/接收控制信号，三态输出，为1发送，为0表示接收。</p><p>中断控制信号引脚</p><p>中断是外部设备请求CPU进行数据传输的有效方法。这一组引脚传输中断的请求和应答信号。</p><ul><li>INTR:可屏蔽中断请求信号</li><li>非INTA：中断响应信号，三态，低电平有效(反馈中断响应信号)</li><li>NMI：不可屏蔽中断请求信号。</li></ul><p>最小模式和最大模式的区别</p><ol><li>最大模式只有一个控制器，最小模式没有控制器</li><li>百分之99，都是最小模式</li></ol><p>DMI控制信号引脚</p><p>DMA传输是一种不经过CPU，在内存和I/O设备之间直接传输数据的方法。进行DMA传输之前要向CPU申请使用总线并取得认可。</p><ol><li>HOLD (Hold Request)：总线请求信号，输入，高电平有效，表示有其他设备向CPU请求使用总线。</li><li>HLDA (Hold Acknowledge)：总线请求响应信号。输出，高电平有效。</li></ol><h3 id="常用的最小模式控制总线信号归纳如下" tabindex="-1"><strong>常用的最小模式控制总线信号归纳如下：</strong> <a class="header-anchor" href="#常用的最小模式控制总线信号归纳如下" aria-label="Permalink to &quot;**常用的最小模式控制总线信号归纳如下：**&quot;">​</a></h3><ul><li>控制存储器/IO端口读写的信号： <ul><li>M/IO非，RD非，WR非，BHE非，DEN非，DT/R非，READY。</li></ul></li><li>用于中断联络和控制的信号： <ul><li>INTR非，INTA非 ， NMI非。</li></ul></li><li>用于DMA联络和控制的信号： <ul><li>HOLD，HLDA。</li></ul></li></ul><h3 id="最小模式下的总线周期" tabindex="-1">最小模式下的总线周期 <a class="header-anchor" href="#最小模式下的总线周期" aria-label="Permalink to &quot;最小模式下的总线周期&quot;">​</a></h3><p><img src="'+m+'" alt="image-20230918202145106"></p><h2 id="最大模式和最小模式" tabindex="-1">最大模式和最小模式 <a class="header-anchor" href="#最大模式和最小模式" aria-label="Permalink to &quot;最大模式和最小模式&quot;">​</a></h2><p>**最小模式：**是指系统中只有一个 8088/8086 处理器，所有的总线控制信号由 8086/8088 产生的，构成系统所需的总线控制逻辑部件最少，最小模式也称 “单处理器模式”</p><p>**最大模式：**系统内可以有一个以上处理器，除了 8086/8088 作为 “中央处理器”外，还可以配置用于数值计算的 8087(数值处理器) 和用于IO管理的8089(IO协处理器) 等，各处理器发往总线的命令统一送往 “总线控制器”，由它 “仲裁” 后发出，8288(总线控制器) 8289(总线仲裁器) 8087(总线收发器)</p><h3 id="最大模式配置" tabindex="-1">最大模式配置： <a class="header-anchor" href="#最大模式配置" aria-label="Permalink to &quot;最大模式配置：&quot;">​</a></h3><p>8086最大模式：</p><ol><li>协处理器： <ol><li>8087(浮点处理器)</li><li>8082(总线控制器)</li><li>8089(总线仲裁器)</li></ol></li></ol><p>协处理器：8087(浮点处理器)、8082(总线控制器)、8089(总线仲裁器)</p><h3 id="最小模式下的典型配置" tabindex="-1">最小模式下的典型配置： <a class="header-anchor" href="#最小模式下的典型配置" aria-label="Permalink to &quot;最小模式下的典型配置：&quot;">​</a></h3><p>需要3个锁存器8282、2个驱动器8086、一个时钟发生器8084</p><p>8086最小模式的典型配置：</p><ol><li>一片8086(20条AB、16条DB、主频各种芯片8位)</li><li>20条的地址锁存器(3片)</li><li>16条数据线(会考虑到电平配平的问题：数据收发器或总线驱动器2片(8286、74xxx24/5))</li><li>时钟源(时钟发生器8284)</li><li>地址锁存器： <ol><li>8282</li><li>74xx273</li><li>74xx373</li></ol></li></ol>',195)]))}const g=a(P,[["render",U]]);export{H as __pageData,g as default};
