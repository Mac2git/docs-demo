import{_ as p,c as t,j as a,a as e,a2 as i,o as n}from"./chunks/framework.3VuPyQdv.js";const l="/docs-demo/emuImage/%E6%95%B0%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F.png",r="/docs-demo/emuImage/ASCII%E7%A0%811.png",o="/docs-demo/emuImage/ASCII%E7%A0%812.png",m="/docs-demo/emuImage/%EF%BC%9F.png",A=JSON.parse('{"title":"伪指令和宏指令","description":"","frontmatter":{},"headers":[],"relativePath":"doc-text/emu/emu05.md","filePath":"doc-text/emu/emu05.md","lastUpdated":1744076169000}'),d={name:"doc-text/emu/emu05.md"},h={class:"MathJax",jax:"SVG",style:{direction:"ltr",position:"relative"}},c={style:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"21.493ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 9500 1000","aria-hidden":"true"};function u(k,s,g,f,b,E){return n(),t("div",null,[s[5]||(s[5]=a("h1",{id:"伪指令和宏指令",tabindex:"-1"},[e("伪指令和宏指令 "),a("a",{class:"header-anchor",href:"#伪指令和宏指令","aria-label":'Permalink to "伪指令和宏指令"'},"​")],-1)),s[6]||(s[6]=a("p",null,"8086宏汇编语言有两种类型的语句:",-1)),a("ol",null,[s[3]||(s[3]=a("li",null,"指令语句：在汇编过程中被翻译成相应的目标代码，经连接后生成可执行的机器指令代码。",-1)),s[4]||(s[4]=a("li",null,"伪指令语句:（指示性语句）在汇编时被解释执行，由汇编程序来处理的一类操作，如数据定义，分配存储器等。",-1)),a("li",null,[a("mjx-container",h,[(n(),t("svg",c,s[0]||(s[0]=[i('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">是</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">地</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">址</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">计</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">数</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">器</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">表</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">示</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(9000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z" style="stroke-width:3;"></path></g></g></g></g>',1)]))),s[1]||(s[1]=a("mjx-assistive-mml",{unselectable:"on",display:"inline",style:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"}},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",{mathvariant:"normal"},"是"),a("mi",{mathvariant:"normal"},"地"),a("mi",{mathvariant:"normal"},"址"),a("mi",{mathvariant:"normal"},"计"),a("mi",{mathvariant:"normal"},"数"),a("mi",{mathvariant:"normal"},"器"),a("mi",null,"，"),a("mi",{mathvariant:"normal"},"表"),a("mi",{mathvariant:"normal"},"示"),a("mrow",{"data-mjx-texclass":"ORD"},[a("mo",null,"/")])])],-1))]),s[2]||(s[2]=e("前面用来多少内存单元的个数，在字符串定义/$表示数据结束符"))])]),s[7]||(s[7]=i('<h2 id="_1、伪指令语句的格式" tabindex="-1"><strong>1、伪指令语句的格式</strong> <a class="header-anchor" href="#_1、伪指令语句的格式" aria-label="Permalink to &quot;**1、伪指令语句的格式**&quot;">​</a></h2><p>格式：符号名 定义符 操作数；注释</p><h3 id="_1、常用伪指令" tabindex="-1">1、常用伪指令 <a class="header-anchor" href="#_1、常用伪指令" aria-label="Permalink to &quot;1、常用伪指令&quot;">​</a></h3><h4 id="_1、符号定义伪指令-赋值语句" tabindex="-1">1、符号定义伪指令（赋值语句） <a class="header-anchor" href="#_1、符号定义伪指令-赋值语句" aria-label="Permalink to &quot;1、符号定义伪指令（赋值语句）&quot;">​</a></h4><p>等值伪指令</p><p>格式：符号名 EQU 表达式</p><p>功能：将表达式的值赋给符号名。</p><p>​ 例: ALFA EQU 100</p><p>​ COUNT EQU ALFA</p><p>注意：符号名一旦被EQU定义，就不能再赋值，即不能用EQU再为符号名重新赋值。</p><h4 id="_2、等号伪指令" tabindex="-1">2、等号伪指令 <a class="header-anchor" href="#_2、等号伪指令" aria-label="Permalink to &quot;2、等号伪指令&quot;">​</a></h4><p>格式：符号名 = 表达式</p><p>功能：将表达式的值赋给符号名。</p><p>说明：可以在程序中不同的地方多次使用以重新为符号名赋值。</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例：  ALFA = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>​ MOV AL，ALFA ；AL←100</p><p>​ ALFA = ALFA+2 ； ALFA = 102</p><h2 id="_2、数据定义伪指令" tabindex="-1">2、数据定义伪指令 <a class="header-anchor" href="#_2、数据定义伪指令" aria-label="Permalink to &quot;2、数据定义伪指令&quot;">​</a></h2><p>格式：[变量名] DB 表达式 ；定义字节</p><p>​ [变量名] DW 表达式 ；定义字</p><p>​ [变量名] DD 表达式 ；定义双字</p><p>​ [变量名] DQ 表达式 ；定义8个字节</p><p>​ [变量名] DT 表达式 ；定义10个字节</p><p>表达式——是赋给变量的初始值，可以有一个，也可 以有多个，常见的有以下几种：</p><h3 id="数值表达式" tabindex="-1">数值表达式 <a class="header-anchor" href="#数值表达式" aria-label="Permalink to &quot;数值表达式&quot;">​</a></h3><p>实际上是为数据分配存储单元，并把变量名作为该存储单元的名称。若要定义多个相同类型的数据，可用逗号把这些数据隔开，并依次分配在相邻的存储单元。</p><p>例:</p><p>​ BUF DB 20H，30H</p><p>​ BUF1 DW 100</p><p>​ DAT DW 1234H，5678H ；字变量DAT的内容为1234H，占用两个字节单元，下一个字单元即DAT+2单元的内容为5678H，仍是低字节存在低地址单元。</p><img src="'+l+'" style="zoom:80%;"><h3 id="ascii字符串" tabindex="-1">ASCII字符串 <a class="header-anchor" href="#ascii字符串" aria-label="Permalink to &quot;ASCII字符串&quot;">​</a></h3><p>​ 字符串必须用引号括起来，并且不超过256个字符，它们在内存中按地址递增顺序自左向右依次存放字符的ASCII码。</p><p>例：STRING DB ‘ABC’</p><p>​ STRING1 DB ‘ How are you? ’</p><p><img src="'+r+'" alt=""></p><p>例: DATA DB ‘AB’</p><p>​ DATA1 DW ‘AB’</p><p><img src="'+o+'" alt=""></p><h3 id="_3、" tabindex="-1">3、？ <a class="header-anchor" href="#_3、" aria-label="Permalink to &quot;3、？&quot;">​</a></h3><p>？——为数据项分配存储单元的一种方法，只是存储单元中不预置确定的值，常用来预留存储单元，存放程序的中间结果或最终结果。</p><p>例: RESULT DB ？；预置一个字节单元，其值不定</p><p>​ ABC DB 12H , ?, ? , 24H</p><p>​ DEF DW ？，895H ,?</p><p><img src="'+m+`" alt=""></p><h3 id="_4、重复定义子句-dup——可以为若干个重复数据分" tabindex="-1">4、重复定义子句 DUP——可以为若干个重复数据分 <a class="header-anchor" href="#_4、重复定义子句-dup——可以为若干个重复数据分" aria-label="Permalink to &quot;4、重复定义子句 DUP——可以为若干个重复数据分&quot;">​</a></h3><p>配存储单元。</p><p>格式: n DUP （表达式）</p><p>说明： n：重复次数 表达式：重复的内容</p><p>例： C DB 100 DUP（0）</p><p>​ TAB DB 100 DUP（5 DUP（1），2）</p><p>注意:</p><p>(1) DUP操作可以嵌套。</p><p>(2)在定义变量及存储单元的同时，也定义了它们的类型属性。同一数据定义语句所定义的各存储单元具有相同的类型。</p><p>例:</p><p>DA1 DB 3 DUP(5，?, 6)； 从DA1地址单元开始存放三组“05H，预留，06H”共9个地址单元</p><p>DA2 DW 40 DUP（？）；从DA2地址单元开始保留40个字共80个地址单元</p><p>DA3 DB 10 DUP(1,2,3 DUP(30，4)；从DA3地址单元开始存放十组“01，02，30，04，30，04,30，04”，共占用80个字节**。**</p><h2 id="_3、段定义伪指令" tabindex="-1">3、段定义伪指令 <a class="header-anchor" href="#_3、段定义伪指令" aria-label="Permalink to &quot;3、段定义伪指令&quot;">​</a></h2><p>格式：</p><p>​ 段名 SEGMENT [定位类型][组合类型][‘类别名’]</p><p>​ ┆段体</p><p>​ 段名 ENDS</p><p>功能：把模块化分为若干个逻辑段。</p><p>​ 每个SEGMENT/ENDS可定义一个逻辑段。</p><h2 id="_4、段寄存器说明伪指令" tabindex="-1">4、段寄存器说明伪指令 <a class="header-anchor" href="#_4、段寄存器说明伪指令" aria-label="Permalink to &quot;4、段寄存器说明伪指令&quot;">​</a></h2><p>格式：</p><p>ASSUME 段寄存器 ：段名[，段寄存器 ：段名…]</p><p>功能：向汇编程序指示当前各段所用的段寄存器，设</p><p>​ 定段寄存器与段的对应关系。</p><p>注意：</p><p>①本伪指令只是指示各逻辑段使用寄存器的情况，并没有对段寄存器内容进行装填。段寄存器的实际值（CS除外）还要由MOV指令在程序中装填数据。</p><p>②也可用来取消段寄存器与段之间的对应关系（用NOTHING），然后再建立新的对应关系。</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例:     	ASSUME   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">： NOTHING</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           ASSUME   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">： DATAB 	       		    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           MOV</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      AX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">， DATAB   装载数据段寄存器	</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">           MOV</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      DS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">， </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AX</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_5、过程定义伪指令" tabindex="-1">5、过程定义伪指令 <a class="header-anchor" href="#_5、过程定义伪指令" aria-label="Permalink to &quot;5、过程定义伪指令&quot;">​</a></h2><p>过程是程序的一部分，它可以被程序调用。每次</p><p>可调用一个过程，当过程中的指令执行完后，控制返</p><p>回调用它的地方。过程的定义是用过程定义伪指令完成的。</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">格式： 过程名   PROC  [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NEAR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> / </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FAR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  ┇    过程体</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                RET</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       过程名   ENDP</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="宏指令" tabindex="-1">宏指令 <a class="header-anchor" href="#宏指令" aria-label="Permalink to &quot;宏指令&quot;">​</a></h2><h3 id="_1、宏定义及其调用" tabindex="-1">1、宏定义及其调用 <a class="header-anchor" href="#_1、宏定义及其调用" aria-label="Permalink to &quot;1、宏定义及其调用&quot;">​</a></h3><p>宏定义格式： 宏指令名 MACRO [形参，形参，┅] ┇ 　宏体</p><p>​ ENDM</p><p>宏调用的格式为： 宏指令名 [实参，实参，┅]</p><p>例：为了实现ASCII码和BCD码之间的相互转换，往往需要把AL中的内容左移或右移4位。设左移4位，可用下列指令序列实现：</p><p>​ MOV CL，4</p><p>​ SAL AL，CL</p><p>若多次使用，则可用一条宏指令来代替，宏定义如下：</p><p>SHIFT MACRO</p><p>MOV CL，4</p><p>SAL AL，CL</p><p>ENDM</p><p>例24：</p><p>​ ┇</p><p>MOV AL，[DI]</p><p>ADD AL，[SI]</p><p>SHIFT ；宏调用</p><p>MOV [BX]，AL</p><p>​ ┇</p>`,99))])}const D=p(d,[["render",u]]);export{A as __pageData,D as default};
