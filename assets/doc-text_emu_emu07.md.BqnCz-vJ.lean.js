import{_ as t,c as e,a2 as l,o}from"./chunks/framework.3VuPyQdv.js";const i="/docs-demo/emuImage/image-20230926190446974.png",r="/docs-demo/emuImage/image-20230926191930793.png",h="/docs-demo/emuImage/image-20230926193902264.png",q=JSON.parse('{"title":"存储器","description":"","frontmatter":{},"headers":[],"relativePath":"doc-text/emu/emu07.md","filePath":"doc-text/emu/emu07.md","lastUpdated":1742718698000}'),d={name:"doc-text/emu/emu07.md"};function n(c,a,p,s,m,u){return o(),e("div",null,a[0]||(a[0]=[l('<h1 id="存储器" tabindex="-1">存储器 <a class="header-anchor" href="#存储器" aria-label="Permalink to &quot;存储器&quot;">​</a></h1><h2 id="存储系统的层次结构" tabindex="-1">存储系统的层次结构 <a class="header-anchor" href="#存储系统的层次结构" aria-label="Permalink to &quot;存储系统的层次结构&quot;">​</a></h2><p>​ MOV指令直接访问存储器</p><p>​ 就是把各种不同存储容量，不同存储速度的存储器，按照一定的体系结构方式组织起来，使所存放的程序数据按层次分布在各种存储器中。</p><p>三级存储系统</p><p>​ 高速缓冲存储器 —— 主存储器 —— 外存储器</p><h3 id="_1、主存储器-——-外存储器-弥补主存容量的不足" tabindex="-1">1、主存储器 —— 外存储器(弥补主存容量的不足) <a class="header-anchor" href="#_1、主存储器-——-外存储器-弥补主存容量的不足" aria-label="Permalink to &quot;1、主存储器 —— 外存储器(弥补主存容量的不足)&quot;">​</a></h3><p>​ 主存(内存)：一般把具体一定容量且速度较高的存储器作为内存，CPU 可直接用指令对内存储器进行读写。存放现行程序和数据，存取速度快，容量有限，是主机的一部分。通常用半导体存储器作为内存。</p><p>​ 外存(辅助或海存)：存储容量大，速度较低，位于主机之外的存储器。用来存放当前暂时不用的程序和数据。CPU 不能直接用指令对外存进行读写，要使用外存中的信息，必须先将它调入内存。</p><p>​ 内存 —— 外存存储层次的形成，解决了存储器的大容量和低成本之间的矛盾。</p><h3 id="主存储器-——-高速缓冲存储器" tabindex="-1">主存储器 —— 高速缓冲存储器 <a class="header-anchor" href="#主存储器-——-高速缓冲存储器" aria-label="Permalink to &quot;主存储器 —— 高速缓冲存储器&quot;">​</a></h3><p>​ 为使用主存储器与 CPU 的速度相匹配，提高 CPU 访问存储器的速度，在 CPU 和内存中间设置高速缓冲器(cache)。</p><p>​ 高速缓存一内存层次的形成了解决速度与成本的矛盾。</p><p>​ 在现代的微机中同时采用这两种存储层次，构成 cache —— 内存 —— 外存 ，三级存储系统。这三级存储系统的形成，满足了现代微型计算机对存储系统的速度快、容量大价格低廉的要求。</p><img src="'+i+'" alt="image-20230926190446974" style="zoom:80%;"><h4 id="高速缓冲存储器-cache" tabindex="-1">高速缓冲存储器(cache) <a class="header-anchor" href="#高速缓冲存储器-cache" aria-label="Permalink to &quot;高速缓冲存储器(cache)&quot;">​</a></h4><p>​ 高速缓冲存储器是存在于主存于 CPU 之间的一级存储器，由静态存储芯片(SRAM) 组成，容量比较小但速度比主存(内存)高得多，接近于 CPU 的速度。它和主存储器一起构成一级的存储器。高速缓冲存储器和主存储器之间信息的调度和传送是由硬件自动进行的。</p><p>​ 某些机器甚至有二级三级缓存，每级缓存比以前一级缓存速度慢且容量大。</p><h2 id="存储器的分类" tabindex="-1">存储器的分类 <a class="header-anchor" href="#存储器的分类" aria-label="Permalink to &quot;存储器的分类&quot;">​</a></h2><ol><li>随机存储器(RAM) <ol><li>即可读又可写，又称读/写存储器，如主存</li></ol></li><li>只读存储器(ROM) <ol><li>只能读，不能写，存放固定不变的系统程序和子程序等。</li></ol></li><li>顺序存储器(SAM)(不考) <ol><li>按照顺序进行读/写，如磁带</li></ol></li></ol><h2 id="存储器的技术指标" tabindex="-1">存储器的技术指标 <a class="header-anchor" href="#存储器的技术指标" aria-label="Permalink to &quot;存储器的技术指标&quot;">​</a></h2><p>​ 容量 = 单元数 × 每个单元数(2的平方，平方是地址线×数据线 )</p><ol><li>存储容量是 —— 通常以允许存放的字位×位数或字节数表示存储器的容量。 <ol><li>32k × 16</li><li>1KB=2的10次方B=1024B，1MB=210KB=1024KB</li></ol></li><li>读取周期(又称读写周期或访问周期) <ol><li>通常以连续存入或取出两个数所间隔的时间。</li></ol></li><li>取数时间 <ol><li>从 CPU 发出读命令开始，直到存储器获得有效读出信号的一段时间。</li></ol></li><li>可靠性 <ol><li>通常以平均无故障工作时间来衡量存储器的可靠性。</li></ol></li><li>经济性 <ol><li>常以 &quot;性能价格比&quot; 来衡量存储器经济性能的好坏。</li></ol></li></ol><h2 id="随机读写存储器" tabindex="-1">随机读写存储器 <a class="header-anchor" href="#随机读写存储器" aria-label="Permalink to &quot;随机读写存储器&quot;">​</a></h2><h3 id="_1、静态ram-sram" tabindex="-1">1、静态RAM(SRAM) <a class="header-anchor" href="#_1、静态ram-sram" aria-label="Permalink to &quot;1、静态RAM(SRAM)&quot;">​</a></h3><p>​ 静态RAM的工作原理</p><p>​ MOS 型静态RAM的基本存储单元，由6个 MOS 场效应晶体管构成，通常用做高速缓冲存储器(cache)。</p><img src="'+r+'" alt="image-20230926191930793" style="zoom:80%;"><p>VF1,VF2：组成双 稳态触发器</p><p>VF3,VF4：负载管</p><p>VF5,VF6：控制管</p><h3 id="_2、静态-ram-组成" tabindex="-1">2、静态 RAM 组成 <a class="header-anchor" href="#_2、静态-ram-组成" aria-label="Permalink to &quot;2、静态 RAM 组成&quot;">​</a></h3><p>​ 将多个存储单元按一定方式排列起来，就组成一个静态 RAM 存储器。</p><p>动态RAM(DRAM)：电容构成，电容不停充电</p><p>​ 特点：</p><p>​ 存储的信息共有一定的时间性，在很短的时间内，其数据是有效的，超过一定的时间，数据就消失了。为了使数据常在，就要周期性地对所在数据重写(刷新)，这种存储器为动态存储器。</p><img src="'+h+'" alt="image-20230926193902264" style="zoom:80%;"><p>(重点) 静态 RAM(SRAM) 和动态 RAM(DRAM)的区别</p><ol><li>DRAM用作为内存比较多，SRAM用作 cache 比较多。</li><li>SRAM 不需要刷新电路就能够保存数据，所有具有静止存取数据的作用。而DRAM则需要不停地刷新电路，否则内部的数据将会消失。</li><li>SRAM追求的速度，所有一般做的比较小(K)，而DRAM追求的仅仅是暂时性的存储数据，所以较大(G)，且较为廉价。</li><li>由于SRAM的容量比较小，所有行和列的地址可以一次性送入，而DRAM则需要将行和列的地址分别送入。</li></ol><h2 id="半导体只读存储器" tabindex="-1">半导体只读存储器 <a class="header-anchor" href="#半导体只读存储器" aria-label="Permalink to &quot;半导体只读存储器&quot;">​</a></h2><h3 id="掩膜式只读存储器-rom" tabindex="-1">掩膜式只读存储器 ROM <a class="header-anchor" href="#掩膜式只读存储器-rom" aria-label="Permalink to &quot;掩膜式只读存储器 ROM&quot;">​</a></h3><p>刚开始掩膜式 ROM 由 &quot;1&quot;、&quot;0&quot;代码矩阵，这种ROM中的信息是永久性存储，使用时只能读出而不能写入新内容。</p><ol><li>ROM： <ol><li>双极型：速度快，容量小</li><li>MOS型：容量大，速度较慢</li></ol></li></ol><h3 id="可编程的只读存储器prom" tabindex="-1">可编程的只读存储器PROM <a class="header-anchor" href="#可编程的只读存储器prom" aria-label="Permalink to &quot;可编程的只读存储器PROM&quot;">​</a></h3><p>制作时不写入信息，使用写入自己的程序，但写入是一次性的，一旦写入就不能更改。</p><ol><li>PROM： <ol><li>双极性： <ol><li>结构破坏性</li><li>熔丝型：使用较多，如：Intel，3036PROM</li></ol></li><li>MOS型</li></ol></li></ol><h3 id="可编程、可擦除的只读存储器——eprom" tabindex="-1">可编程、可擦除的只读存储器——EPROM <a class="header-anchor" href="#可编程、可擦除的只读存储器——eprom" aria-label="Permalink to &quot;可编程、可擦除的只读存储器——EPROM&quot;">​</a></h3><p>​ 用户使用可重复编程、可多次改写所写内容</p><h4 id="_1、紫外线擦除的-eprom" tabindex="-1">1、紫外线擦除的 EPROM <a class="header-anchor" href="#_1、紫外线擦除的-eprom" aria-label="Permalink to &quot;1、紫外线擦除的 EPROM&quot;">​</a></h4><p>​ 采用紫外线擦去原存内容，再用专门写入器改写内容，因此又称 UVEPROM。用紫外线(或X射线)灯，相距3cm，进行照射 10~20min就可把 EPROM 中的原存全部信息抹去，并成为全 &quot;1&quot; 状态，再根据用户程序，用加电压的手段使要存入 &quot;0&quot; 的那些存储位进行写 &quot;0&quot;，而对要 &quot;1&quot; 的存储位不加电压，仍保持原有的 &quot;1&quot; 代码。</p><h4 id="_2、电可擦除只读存储器" tabindex="-1">2、电可擦除只读存储器 <a class="header-anchor" href="#_2、电可擦除只读存储器" aria-label="Permalink to &quot;2、电可擦除只读存储器&quot;">​</a></h4><p>​ 简称为 EEPROM 或 E2PROM。</p><p>​ 它是采用金属—氮—氧化物—硅（MNOS）集成工艺制成的。使用时让电流只通过指定的存储单元，把其中一个字（或字节）擦去并改写，其余未通入电流的单元内容保持不变。</p><table tabindex="0"><thead><tr><th style="text-align:center;">400H = 1K</th></tr></thead><tbody><tr><td style="text-align:center;">800H = 2K</td></tr><tr><td style="text-align:center;">1000H = 4K</td></tr><tr><td style="text-align:center;">2000H = 8K</td></tr><tr><td style="text-align:center;">4000H=16k</td></tr><tr><td style="text-align:center;">8000H=32k</td></tr><tr><td style="text-align:center;">1 0000=64K</td></tr><tr><td style="text-align:center;">2 0000=128K</td></tr><tr><td style="text-align:center;">4 0000=256K</td></tr><tr><td style="text-align:center;">8 0000=512K</td></tr></tbody></table>',54)]))}const R=t(d,[["render",n]]);export{q as __pageData,R as default};
