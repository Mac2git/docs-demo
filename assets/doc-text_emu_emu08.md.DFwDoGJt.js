import{_ as l,c as e,a2 as i,o}from"./chunks/framework.3VuPyQdv.js";const t="/docs-demo/emuImage/image-20230927163624629.png",s="/docs-demo/emuImage/image-20230927163736490.png",r="/docs-demo/emuImage/DRAM%E5%8A%A8%E6%80%812164%E8%8A%AF%E7%89%87.png",m="/docs-demo/emuImage/%E5%8A%A8%E6%80%81DRAM2164.png",M=JSON.parse('{"title":"SRAM-6264(静态RAM) 和DRAM(动态RAM2164)","description":"","frontmatter":{},"headers":[],"relativePath":"doc-text/emu/emu08.md","filePath":"doc-text/emu/emu08.md","lastUpdated":1744538836000}'),d={name:"doc-text/emu/emu08.md"};function n(c,a,A,p,h,u){return o(),e("div",null,a[0]||(a[0]=[i('<h1 id="sram-6264-静态ram-和dram-动态ram2164" tabindex="-1">SRAM-6264(静态RAM) 和DRAM(动态RAM2164) <a class="header-anchor" href="#sram-6264-静态ram-和dram-动态ram2164" aria-label="Permalink to &quot;SRAM-6264(静态RAM) 和DRAM(动态RAM2164)&quot;">​</a></h1><h2 id="sram-6264-2的标准地址线×数据线" tabindex="-1">SRAM-6264(2的标准地址线×数据线) <a class="header-anchor" href="#sram-6264-2的标准地址线×数据线" aria-label="Permalink to &quot;SRAM-6264(2的标准地址线×数据线)&quot;">​</a></h2><img src="'+t+'" alt="image-20230927163624629" style="zoom:80%;"><ol><li>芯片地址译码是 A0~A12共13位地址译码电路</li><li>芯片有I/O0-I/O7共八位数据传送线</li><li>所以该芯片是8K*8位的。</li></ol><img src="'+s+'" alt="image-20230927163736490" style="zoom:80%;"><h2 id="dram-2164-功能及使用特性-2条db、8条ab" tabindex="-1">DRAM 2164 功能及使用特性(2条DB、8条AB) <a class="header-anchor" href="#dram-2164-功能及使用特性-2条db、8条ab" aria-label="Permalink to &quot;DRAM 2164 功能及使用特性(2条DB、8条AB)&quot;">​</a></h2><p><img src="'+r+'" alt=""></p><p>2164容量为64k×1bit，内部有65536个动态存储单元。整个芯片每 2ms需要刷新一遍，若每次刷新512个存储单元。64k个存储单元需要有128个刷新周期，则每个刷新周期为 15.625 μs(微秒) 封装时仅将8条地址线引出到芯片外部引脚，即 A0~A7</p><img src="'+m+'" style="zoom:80%;"><p>特点：行和列分两部分送进去</p><h3 id="dram-2164读写原理" tabindex="-1">DRAM 2164读写原理 <a class="header-anchor" href="#dram-2164读写原理" aria-label="Permalink to &quot;DRAM 2164读写原理&quot;">​</a></h3><p>先由行地址选通信号，行地址选通信号 RAS 将先送入的8位行地址到片内行地址锁存器，然后由列地址选通信号 CAS 将后送入的8位列地址送到片内地址锁存器。16位地址信号选中64k个存储单元的一个单元。</p><p>数据线是输入和输出分开的，由 WE 信号控制读写，无专门的片选信号。</p><p>DRAM2164，它会选中4部分的同一行进行刷新，每次刷新512个单元。</p><h4 id="dram-2164-一共有三种刷新方式" tabindex="-1">DRAM 2164 一共有三种刷新方式 <a class="header-anchor" href="#dram-2164-一共有三种刷新方式" aria-label="Permalink to &quot;DRAM 2164 一共有三种刷新方式&quot;">​</a></h4><p>刷新：是对信息读出在写入(假读)，所以所需要的时间是0.5 μs(微秒)。一共 128×0.5 μs(微秒) = 64 μs(微秒)</p><ol><li>集中刷新：(有死区) <ol><li>在规定的一个刷新周期内(128个周期)，对全部存储单元，集中一段时间逐进行刷新(用专门的时间进行刷新，刷新的时间不能被访问)</li><li>每2ms刷新一次，64k单元(间隔)</li><li>每一次刷新512单元，需 0.5μs(微秒)，128×0.5=64 μs(微秒，刷新时间)</li></ol></li><li>分散刷新： <ol><li>是指对每行存储单元的刷新分散到每个存储周期完成(对某一行某芯片进行读写操作后，紧接着刷新，包含在了读写周期内) 刷新的时间：读写 0.5 μs+ 刷新 0.5 μs <ol><li>例：对128×128的矩阵的存储芯片进行刷新，读/写周期为 0.5 μs (读或写一次) 将刷新分散到存储周期内完成，则存储周期就包含了刷新时间。</li></ol></li><li>优点：无死区</li><li>缺点：存储周期长，整个系统的速度降低了。</li></ol></li><li>异步刷新(DRAM 2164 的选用方式)： <ol><li>前两种的结合，缩短了时间，充分利用了最大刷新间隔为 2ms的特点(只要2ms内对这一行进行刷新一遍就行)。 <ol><li>例：对128×128的矩阵的存储芯片进行刷新，存储周期为0.5s，刷新周期为2ms。</li><li>2ms对每行刷新一遍。 <ol><li>2000 μs ÷ 128 ≈ 15.6 μs</li></ol></li><li>即每隔 15.6 μs刷新一行，每行的刷新时间仍然为 0.5 μs，刷新一行就停一个存储周期，&quot;死时间缩短了为 0.5 μs&quot;(15.6μs内刷新一行，其他全用来读写)。</li></ol></li><li>这种方案克服了分散刷新许独占 0.5μs 用于刷新，使存取周期加长且降低速度的缺点，又不会出现集中刷新的访问，&quot;死区&quot;问题，从根本上提高了工作效率。</li></ol></li></ol><h2 id="dram2164总结" tabindex="-1">DRAM2164总结 <a class="header-anchor" href="#dram2164总结" aria-label="Permalink to &quot;DRAM2164总结&quot;">​</a></h2><ol><li>2164容量是 64k × 1位 ，为减少引脚，地址线分为两部分：行地址和列地址。</li><li>数据线的输入和输出是分开的。每一次刷新 512 个存储单元。</li><li>异步刷新是最终采用的方式，异步刷新 2ms 刷新 128 行 每个刷新周期 15.625 μs (微秒)</li></ol>',19)]))}const D=l(d,[["render",n]]);export{M as __pageData,D as default};
