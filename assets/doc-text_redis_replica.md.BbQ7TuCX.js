import{_ as e,c as l,a2 as s,o as a}from"./chunks/framework.3VuPyQdv.js";const m="/docs-demo/redisImages/image-20250416160335729.png",o="/docs-demo/redisImages/image-20250416165241212.png",r="/docs-demo/redisImages/image-20250416165307679.png",t="/docs-demo/redisImages/image-20250416165412427.png",g="/docs-demo/redisImages/image-20250416165619557.png",d="/docs-demo/redisImages/image-20250416165720318.png",c="/docs-demo/redisImages/image-20250416165819294.png",p="/docs-demo/redisImages/image-20250416165901873.png",n="/docs-demo/redisImages/image-20250416170002549.png",_="/docs-demo/redisImages/image-20250416170101192.png",u="/docs-demo/redisImages/image-20250416170152373.png",I="/docs-demo/redisImages/image-20250416170236656.png",h="/docs-demo/redisImages/image-20250416170351266.png",f="/docs-demo/redisImages/image-20250416170415481.png",v="/docs-demo/redisImages/image-20250416170638143.png",x="/docs-demo/redisImages/image-20250418211505189.png",k="/docs-demo/redisImages/image-20250418211822625.png",q="/docs-demo/redisImages/image-20250418224045300.png",b="/docs-demo/redisImages/image-20250418224709693.png",P="/docs-demo/redisImages/image-20250418224817758.png",w="/docs-demo/redisImages/image-20250418224136632.png",$="/docs-demo/redisImages/image-20250418224349195.png",B="/docs-demo/redisImages/image-20250418224431124.png",N="/docs-demo/redisImages/image-20250418225224247.png",S="/docs-demo/redisImages/image-20250418225407582.png",y="/docs-demo/redisImages/image-20250418225601215.png",z=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"doc-text/redis/replica.md","filePath":"doc-text/redis/replica.md","lastUpdated":1744988365000}'),D={name:"doc-text/redis/replica.md"};function E(J,i,O,U,V,Y){return a(),l("div",null,i[0]||(i[0]=[s('<h2 id="复制-replica" tabindex="-1">复制（replica） <a class="header-anchor" href="#复制-replica" aria-label="Permalink to &quot;复制（replica）&quot;">​</a></h2><p>就是主从复制，master以写为主，slave以读为主。当master数据变化的时候，自动将新的数据异步同步到其他slave数据库</p><p>优点：</p><ul><li>读写分离</li><li>容灾恢复</li><li>数据备份</li><li>水平扩容支撑高并发</li></ul><p>如何使用</p><ul><li>配从（库）不配主（库）</li><li>权限细节，重要 <ul><li>master 如果配置了 requirepass 参数，需要密码登录</li><li>那么 slave 就要配置 masterauth 来设置校验密码，否则的话 master 会拒绝 slave的访问请求 <ul><li><img src="'+m+'" alt="image-20250416160335729"></li></ul></li></ul></li><li>基本操作命令 <ul><li>info replication：可以查看复制节点的主从关系和配置信息</li><li>replicaof 主库IP 主库端口：一般写入进 redis.conf 配置文件内</li><li>slaveof 主库IP 主库端口 <ul><li>每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件</li><li>在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系<strong>转而和新的主数据库同步，重新拜主数据库</strong></li></ul></li><li>slaveof no one：使当前数据库停止与其他数据库的同步，<strong>转成主数据库，自立为王</strong></li></ul></li></ul><h3 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h3><ul><li>架构说明 <ul><li>一个 master 两个 slave</li><li>拷贝多个redis.conf 文件 <ul><li>redis6379.conf</li><li>redis6380.conf</li><li>redis6381.conf <ul><li><img src="'+o+'" alt="image-20250416165241212"></li><li><img src="'+r+'" alt="image-20250416165307679"></li><li><img src="'+t+'" alt="image-20250416165412427"></li></ul></li></ul></li><li>修改配置文件 <ul><li>以redis6380为例，redis6381跟redis6380一样 <ul><li><img src="'+g+'" alt="image-20250416165619557"></li><li><img src="'+d+'" alt="image-20250416165720318"></li><li><img src="'+c+'" alt="image-20250416165819294"></li><li><img src="'+p+'" alt="image-20250416165901873"></li><li><img src="'+n+'" alt="image-20250416170002549"></li><li><img src="'+_+'" alt="image-20250416170101192"></li><li><img src="'+u+'" alt="image-20250416170152373"></li><li><img src="'+I+'" alt="image-20250416170236656"></li><li><img src="'+h+'" alt="image-20250416170351266"></li><li><img src="'+f+'" alt="image-20250416170415481"></li><li><img src="'+v+'" alt="image-20250416170638143"></li></ul></li></ul></li><li>效果，启动redis6379、redis6380、redis6381，并查看（如果连接不上试试ping命令 ，看看是否可以和主机ping通，如果ping不通关闭防火墙<code>systemctl stop firewalld</code>） <ul><li>如果端口号不是 6379 启动的时候加上端口号，如果不加默认6379 <ul><li><img src="'+x+'" alt="image-20250418211505189"></li></ul></li><li>启动两个从机 <ul><li><img src="'+k+'" alt="image-20250418211822625"></li><li><img src="'+q+'" alt="image-20250418224045300"></li><li>主机日志查看 连接 <ul><li><img src="'+b+'" alt="image-20250418224709693"></li></ul></li><li>从机日志查看连接 <ul><li><img src="'+P+'" alt="image-20250418224817758"></li></ul></li><li>主机 <ul><li><img src="'+w+'" alt="image-20250418224136632"></li></ul></li><li><img src="'+$+'" alt="image-20250418224349195"></li><li>使用从机访问试试 <ul><li><img src="'+B+'" alt="image-20250418224431124"></li></ul></li></ul></li></ul></li></ul></li></ul><p>问题：</p><ol><li><p>从机可以执行写命令吗？</p><p><img src="'+N+'" alt="image-20250418225224247"></p></li><li><p>从机切入点问题</p><p>slave是从头开始复制还是从切入点开始复制?</p><p>master启动，写到k3</p><p>slave1跟着master同时启动，跟着写到k3</p><p>slave2写到k3后才启动，那之前的是否也可以复制？</p><p>Y，首次一锅端，后续跟随，master写，slave跟</p></li><li><p>主机shutdown后，从机会不会上位</p><p>从机不动，原地待命，从机数据可以正常使用；等待主机重启动归来</p></li><li><p>主机shutdown后，重启后主从关系还在吗？从机还能否顺利复制？</p><p><img src="'+S+'" alt="image-20250418225407582"></p></li><li><p>某台从机down后，master继续，从机重启后它能跟上主机吗？</p><p>可以</p></li></ol><h3 id="命令操作主从关系" tabindex="-1">命令操作主从关系 <a class="header-anchor" href="#命令操作主从关系" aria-label="Permalink to &quot;命令操作主从关系&quot;">​</a></h3><p><img src="'+y+'" alt="image-20250418225601215"></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>配置，持久稳定</p><p>命令，当次生效</p>',15)]))}const A=e(D,[["render",E]]);export{z as __pageData,A as default};
