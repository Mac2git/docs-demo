import{_ as t,c as s,a2 as e,o as i}from"./chunks/framework.3VuPyQdv.js";const r="/docs-demo/wxImages/%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6.png",o="/docs-demo/wxImages/%E5%B1%80%E9%83%A8%E5%BC%95%E7%94%A8%E7%BB%84%E4%BB%B6.png",h="/docs-demo/wxImages/%E5%85%A8%E5%B1%80%E5%BC%95%E7%94%A8%E7%BB%84%E4%BB%B6.png",l="/docs-demo/wxImages/%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB.png",n="/docs-demo/wxImages/%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F%E9%9A%94%E7%A6%BB%E9%80%89%E9%A1%B9.png",p="/docs-demo/wxImages/data%E6%95%B0%E6%8D%AE.png",d="/docs-demo/wxImages/methods%E6%96%B9%E6%B3%95.png",E="/docs-demo/wxImages/properties%E5%B1%9E%E6%80%A7.png",m="/docs-demo/wxImages/data%E5%92%8Cproperties%E7%9A%84%E5%8C%BA%E5%88%AB.png",c="/docs-demo/wxImages/%E4%BD%BF%E7%94%A8setData%E4%BF%AE%E6%94%B9properties%E7%9A%84%E5%80%BC.png",g="/docs-demo/wxImages/%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E5%99%A8.png",k="/docs-demo/wxImages/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.png",b="/docs-demo/wxImages/%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%952.png",B="/docs-demo/wxImages/%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96.png",A="/docs-demo/wxImages/%E7%BA%AF%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99.png",_="/docs-demo/wxImages/%E4%BD%BF%E7%94%A8%E7%BA%AF%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5%E6%94%B9%E9%80%A0%E6%95%B0%E6%8D%AE%E7%9B%91%E5%90%AC%E5%99%A8.png",u="/docs-demo/wxImages/lifetimes%E8%8A%82%E7%82%B9.png",y="/docs-demo/wxImages/pageLifetimes%E8%8A%82%E7%82%B9.png",x="/docs-demo/wxImages/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%9A%84RGB%E9%A2%9C%E8%89%B2%E5%80%BC.png",q="/docs-demo/wxImages/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%9A%84RGB%E9%A2%9C%E8%89%B2%E5%80%BC2.png",f="/docs-demo/wxImages/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E6%A7%BD.png",w="/docs-demo/wxImages/%E5%8D%95%E4%B8%AA%E6%8F%92%E6%A7%BD.png",v="/docs-demo/wxImages/%E5%90%AF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%8F%92%E6%A7%BD.png",F="/docs-demo/wxImages/%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E6%8F%92%E6%A7%BD.png",D="/docs-demo/wxImages/%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%8F%92%E6%A7%BD.png",P="/docs-demo/wxImages/%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A.png",C="/docs-demo/wxImages/%E5%AD%90%E7%BB%84%E4%BB%B6properties%E8%8A%82%E7%82%B9%E4%B8%AD%E7%94%9F%E5%91%BD%E5%AF%B9%E5%BA%94%E7%9A%84%E5%B1%9E%E6%80%A7%E5%B9%B6%E4%BD%BF%E7%94%A8.png",I="/docs-demo/wxImages/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%AD%A5%E9%AA%A4%E4%B8%80.png",z="/docs-demo/wxImages/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%AD%A5%E9%AA%A4%E4%BA%8C.png",j="/docs-demo/wxImages/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%AD%A5%E9%AA%A4%E4%B8%89.png",O="/docs-demo/wxImages/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%AD%A5%E9%AA%A4%E5%9B%9B.png",S="/docs-demo/wxImages/%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B.png",G="/docs-demo/wxImages/%E4%BB%80%E4%B9%88%E6%98%AFbehaviors.png",R="/docs-demo/wxImages/%E5%88%9B%E5%BB%BAbehaviors.png",L="/docs-demo/wxImages/%E5%AF%BC%E5%85%A5%E5%B9%B6%E4%BD%BF%E7%94%A8behavior.png",Q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"doc-text/wx/wx26.md","filePath":"doc-text/wx/wx26.md","lastUpdated":1753086663000}'),V={name:"doc-text/wx/wx26.md"};function $(N,a,U,J,M,H){return i(),s("div",null,a[0]||(a[0]=[e('<h2 id="_25-自定义组件-组件的创建与引用" tabindex="-1">25. 自定义组件-组件的创建与引用 <a class="header-anchor" href="#_25-自定义组件-组件的创建与引用" aria-label="Permalink to &quot;25. 自定义组件-组件的创建与引用&quot;">​</a></h2><h4 id="_1-创建组件" tabindex="-1">1. 创建组件 <a class="header-anchor" href="#_1-创建组件" aria-label="Permalink to &quot;1. 创建组件&quot;">​</a></h4><p>​ ①在项目的根目录中，鼠标右键，创建 components -&gt; test 文件夹</p><p>​ ②在新建的 components -&gt; test 文件夹上，鼠标右键，点击“新建 Component”</p><p>​ ③键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss</p><p>​ 注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中，例如：</p><p>​ <img src="'+r+'" alt="image-20230311232230352" style="zoom:67%;"></p><hr><h4 id="_2-引用组件" tabindex="-1">2. 引用组件 <a class="header-anchor" href="#_2-引用组件" aria-label="Permalink to &quot;2. 引用组件&quot;">​</a></h4><p>​ 组件的引用方式分为“局部引用”和“全局引用”，顾名思义：</p><p>​ 局部引用：组件只能在当前被引用的页面内使用</p><p>​ 全局引用：组件可以在每个小程序页面中使用</p><hr><h4 id="_3-局部引用组件" tabindex="-1">3. 局部引用组件 <a class="header-anchor" href="#_3-局部引用组件" aria-label="Permalink to &quot;3. 局部引用组件&quot;">​</a></h4><p>​ 在页面的 .json 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下：</p><img src="'+o+'" alt="image-20230311232419947" style="zoom:50%;"><hr><h4 id="_4-全局引用组件" tabindex="-1">4. 全局引用组件 <a class="header-anchor" href="#_4-全局引用组件" aria-label="Permalink to &quot;4. 全局引用组件&quot;">​</a></h4><p>​ 在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下：</p><img src="'+h+'" alt="image-20230311232508909" style="zoom:50%;"><hr><h4 id="_5-全局引用-vs-局部引用" tabindex="-1">5. 全局引用 VS 局部引用 <a class="header-anchor" href="#_5-全局引用-vs-局部引用" aria-label="Permalink to &quot;5. 全局引用 VS 局部引用&quot;">​</a></h4><p>​ 根据组件的使用频率和范围，来选择合适的引用方式：</p><p>​ 如果某组件在多个页面中经常被用到，建议进行“全局引用”</p><p>​ 如果某组件只在特定的页面中被用到，建议进行“局部引用”</p><hr><h4 id="_6-组件和页面的区别" tabindex="-1">6. 组件和页面的区别 <a class="header-anchor" href="#_6-组件和页面的区别" aria-label="Permalink to &quot;6. 组件和页面的区别&quot;">​</a></h4><p>​ 从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 .json 文件有明显的不同：</p><p>​ 组件的 .json 文件中需要声明 &quot;component&quot;: true 属性</p><p>​ 组件的 .js 文件中调用的是 Component() 函数</p><p>​ 组件的事件处理函数需要定义到 methods 节点中</p><hr><h4 id="自定义组件-样式" tabindex="-1">自定义组件 - 样式 <a class="header-anchor" href="#自定义组件-样式" aria-label="Permalink to &quot;自定义组件 - 样式&quot;">​</a></h4><h4 id="_1-组件样式隔离" tabindex="-1">1. 组件样式隔离 <a class="header-anchor" href="#_1-组件样式隔离" aria-label="Permalink to &quot;1. 组件样式隔离&quot;">​</a></h4><p>​ 默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，如图所示：</p><p>​ 组件 A 的样式不会影响组件 C 的样式</p><p>​ 组件 A 的样式不会影响小程序页面的样式</p><p>​ 小程序页面的样式不会影响组件 A 和 C 的样式</p><p>​ 好处：</p><p>​ ①防止外界的样式影响组件内部的样式</p><p>​ ②防止组件的样式破坏外界的样式</p><img src="'+l+'" alt="image-20230311232743155" style="zoom:50%;"><hr><h4 id="_2-组件样式隔离的注意点" tabindex="-1">2. 组件样式隔离的注意点 <a class="header-anchor" href="#_2-组件样式隔离的注意点" aria-label="Permalink to &quot;2. 组件样式隔离的注意点&quot;">​</a></h4><p>​ app.wxss 中的全局样式对组件无效</p><p>​ 只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响</p><blockquote><p>​ 建议：在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器！</p></blockquote><hr><h4 id="_3-修改组件的样式隔离选项" tabindex="-1">3. 修改组件的样式隔离选项 <a class="header-anchor" href="#_3-修改组件的样式隔离选项" aria-label="Permalink to &quot;3. 修改组件的样式隔离选项&quot;">​</a></h4><p>​ 默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能够控制组件内部的样式，此时，可以通过 styleIsolation 修改组件的样式隔离选项，用法如下：</p><img src="'+n+'" alt="image-20230311232915605" style="zoom:50%;"><hr><h4 id="_4-styleisolation-的可选值" tabindex="-1">4. styleIsolation 的可选值 <a class="header-anchor" href="#_4-styleisolation-的可选值" aria-label="Permalink to &quot;4. styleIsolation 的可选值&quot;">​</a></h4><table tabindex="0"><thead><tr><th>可选值</th><th>默认值</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td>isolated</td><td>是</td><td style="text-align:left;">表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响</td></tr><tr><td>apply-shared</td><td>否</td><td style="text-align:left;">表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面</td></tr><tr><td>shared</td><td>否</td><td style="text-align:left;">表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件</td></tr></tbody></table><hr><h4 id="自定义组件-数据、方法和属性" tabindex="-1">自定义组件 - 数据、方法和属性 <a class="header-anchor" href="#自定义组件-数据、方法和属性" aria-label="Permalink to &quot;自定义组件 - 数据、方法和属性&quot;">​</a></h4><p>​</p><h4 id="_1-data-数据" tabindex="-1">1. data 数据 <a class="header-anchor" href="#_1-data-数据" aria-label="Permalink to &quot;1. data 数据&quot;">​</a></h4><p>​ 在小程序组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中，示例如下：</p><img src="'+p+'" alt="image-20230311233115908" style="zoom:50%;"><hr><h4 id="_2-methods-方法" tabindex="-1">2. methods 方法 <a class="header-anchor" href="#_2-methods-方法" aria-label="Permalink to &quot;2. methods 方法&quot;">​</a></h4><p>​ 在小程序组件中，事件处理函数和自定义方法需要定义到 methods 节点中，示例代码如下：</p><img src="'+d+'" alt="image-20230311233151994" style="zoom:50%;"><hr><h4 id="_3-properties-属性" tabindex="-1">3. properties 属性 <a class="header-anchor" href="#_3-properties-属性" aria-label="Permalink to &quot;3. properties 属性&quot;">​</a></h4><p>​ 在小程序组件中，properties 是组件的对外属性，用来接收外界传递到组件中的数据，示例代码如下：</p><img src="'+E+'" alt="image-20230311233232662" style="zoom:50%;"><hr><h4 id="_4-data-和-properties-的区别" tabindex="-1">4. data 和 properties 的区别 <a class="header-anchor" href="#_4-data-和-properties-的区别" aria-label="Permalink to &quot;4. data 和 properties 的区别&quot;">​</a></h4><p>​ 在小程序的组件中，properties 属性和 data 数据的用法相同，它们都是可读可写的，只不过：</p><p>​ data 更倾向于存储组件的私有数据</p><p>​ properties 更倾向于存储外界传递到组件中的数据</p><img src="'+m+'" alt="image-20230311233321961" style="zoom:50%;"><hr><h4 id="_5-使用-setdata-修改-properties-的值" tabindex="-1">5. 使用 setData 修改 properties 的值 <a class="header-anchor" href="#_5-使用-setdata-修改-properties-的值" aria-label="Permalink to &quot;5. 使用 setData 修改 properties 的值&quot;">​</a></h4><p>​ 由于 data 数据和 properties 属性在本质上没有任何区别，因此 properties 属性的值也可以用于页面渲染，或使用 setData 为 properties 中的属性重新赋值，示例代码如下：</p><img src="'+c+'" alt="image-20230311233417067" style="zoom:50%;"><hr><h4 id="自定义组件-数据监听器" tabindex="-1">自定义组件 - 数据监听器 <a class="header-anchor" href="#自定义组件-数据监听器" aria-label="Permalink to &quot;自定义组件 - 数据监听器&quot;">​</a></h4><h4 id="_1-什么是数据监听器" tabindex="-1">1. 什么是数据监听器 <a class="header-anchor" href="#_1-什么是数据监听器" aria-label="Permalink to &quot;1. 什么是数据监听器&quot;">​</a></h4><p>​ 数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 vue 中的 watch 侦听器。在小程序组件中，数据监听器的基本语法格式如下：</p><img src="'+g+'" alt="image-20230311233607306" style="zoom:50%;"><hr><h4 id="_2-数据监听器的基本用法" tabindex="-1">2. 数据监听器的基本用法 <a class="header-anchor" href="#_2-数据监听器的基本用法" aria-label="Permalink to &quot;2. 数据监听器的基本用法&quot;">​</a></h4><p>​ 组件的 UI 结构如下：</p><img src="'+k+'" alt="image-20230311233647223" style="zoom:67%;"><p>​ 组件的 .js 文件代码如下：</p><img src="'+b+'" alt="image-20230311233731699" style="zoom:67%;"><hr><h4 id="_3-监听对象属性的变化" tabindex="-1">3. 监听对象属性的变化 <a class="header-anchor" href="#_3-监听对象属性的变化" aria-label="Permalink to &quot;3. 监听对象属性的变化&quot;">​</a></h4><p>​ 数据监听器支持监听对象中单个或多个属性的变化，示例语法如下：</p><img src="'+B+'" alt="image-20230311233818003" style="zoom:67%;"><hr><h4 id="自定义组件-纯数据字段" tabindex="-1">自定义组件 - 纯数据字段 <a class="header-anchor" href="#自定义组件-纯数据字段" aria-label="Permalink to &quot;自定义组件 - 纯数据字段&quot;">​</a></h4><p>​</p><h4 id="_1-什么是纯数据字段" tabindex="-1">1. 什么是纯数据字段 <a class="header-anchor" href="#_1-什么是纯数据字段" aria-label="Permalink to &quot;1. 什么是纯数据字段&quot;">​</a></h4><p>​ 概念：纯数据字段指的是那些不用于界面渲染的 data 字段。</p><p>​ 应用场景：例如有些情况下，某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段。</p><p>​ 好处：纯数据字段有助于提升页面更新的性能。</p><hr><h4 id="_2-使用规则" tabindex="-1">2. 使用规则 <a class="header-anchor" href="#_2-使用规则" aria-label="Permalink to &quot;2. 使用规则&quot;">​</a></h4><p>​ 在 Component 构造器的 options 节点中，指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段，示例代码如下：</p><p>​ <img src="'+A+'" alt="image-20230311234000169" style="zoom:67%;"></p><hr><h4 id="_3-使用纯数据字段改造数据监听器案例" tabindex="-1">3. 使用纯数据字段改造数据监听器案例 <a class="header-anchor" href="#_3-使用纯数据字段改造数据监听器案例" aria-label="Permalink to &quot;3. 使用纯数据字段改造数据监听器案例&quot;">​</a></h4><p>​ <img src="'+_+'" alt="image-20230311234045991" style="zoom:67%;"></p><hr><h4 id="自定义组件-组件的生命周期" tabindex="-1">自定义组件 - 组件的生命周期 <a class="header-anchor" href="#自定义组件-组件的生命周期" aria-label="Permalink to &quot;自定义组件 - 组件的生命周期&quot;">​</a></h4><h4 id="_1-组件全部的生命周期函数" tabindex="-1">1. 组件全部的生命周期函数 <a class="header-anchor" href="#_1-组件全部的生命周期函数" aria-label="Permalink to &quot;1. 组件全部的生命周期函数&quot;">​</a></h4><p>​ 小程序组件可用的全部生命周期如下表所示：</p><table tabindex="0"><thead><tr><th>生命周期函数</th><th>参数</th><th>描述说明</th></tr></thead><tbody><tr><td>created</td><td>无</td><td>在组件实例刚刚被创建时执行</td></tr><tr><td>attached</td><td>无</td><td>在组件实例进入页面节点树时执行</td></tr><tr><td>ready</td><td>无</td><td>在组件在视图层布局完成后执行</td></tr><tr><td>moved</td><td>无</td><td>在组件实例被移动到节点树另一个位置时执行</td></tr><tr><td>detached</td><td>无</td><td>在组件实例被从页面节点树移除时执行</td></tr><tr><td>error</td><td>Object Error</td><td>每当组件方法抛出错误时执行</td></tr></tbody></table><hr><h4 id="_2-组件主要的生命周期函数" tabindex="-1">2. 组件主要的生命周期函数 <a class="header-anchor" href="#_2-组件主要的生命周期函数" aria-label="Permalink to &quot;2. 组件主要的生命周期函数&quot;">​</a></h4><p>​ 在小程序组件中，最重要的生命周期函数有 3 个，分别是 created、attached、detached。它们各自的特点如下：</p><p>​ ① 组件实例刚被创建好的时候，created 生命周期函数会被触发</p><p>​ 此时还不能调用 setData</p><p>​ 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段</p><p>​ ② 在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发</p><p>​ 此时， this.data 已被初始化完毕</p><p>​ 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）</p><p>​ ③ 在组件离开页面节点树后， detached 生命周期函数会被触发</p><p>​ 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数</p><p>​ 此时适合做一些清理性质的工作</p><hr><h4 id="_3-lifetimes-节点" tabindex="-1">3. lifetimes 节点 <a class="header-anchor" href="#_3-lifetimes-节点" aria-label="Permalink to &quot;3. lifetimes 节点&quot;">​</a></h4><p>​</p><p>​ 在小程序组件中，生命周期函数可以直接定义在 Component 构造器的第一级参数中，可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。示例代码如下：</p><img src="'+u+'" alt="image-20230311234451926" style="zoom:67%;"><hr><h4 id="自定义组件-组件所在页面的生命周期" tabindex="-1">自定义组件 - 组件所在页面的生命周期 <a class="header-anchor" href="#自定义组件-组件所在页面的生命周期" aria-label="Permalink to &quot;自定义组件 - 组件所在页面的生命周期&quot;">​</a></h4><h4 id="_1-什么是组件所在页面的生命周期" tabindex="-1">1. 什么是组件所在页面的生命周期 <a class="header-anchor" href="#_1-什么是组件所在页面的生命周期" aria-label="Permalink to &quot;1. 什么是组件所在页面的生命周期&quot;">​</a></h4><p>​ 有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。</p><p>​ 例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。</p><p>​ 在自定义组件中，组件所在页面的生命周期函数有如下 3 个，分别是：</p><table tabindex="0"><thead><tr><th>生命周期函数</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>show</td><td>无</td><td>组件所在的页面被展示时执行</td></tr><tr><td>hide</td><td>无</td><td>组件所在的页面被隐藏时执行</td></tr><tr><td>resize</td><td>Object Size</td><td>组件所在的页面尺寸变化时执行</td></tr></tbody></table><hr><h4 id="_2-pagelifetimes-节点" tabindex="-1">2. pageLifetimes 节点 <a class="header-anchor" href="#_2-pagelifetimes-节点" aria-label="Permalink to &quot;2. pageLifetimes 节点&quot;">​</a></h4><p>​ 组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中，示例代码如下：</p><img src="'+y+'" alt="image-20230311234617795" style="zoom:67%;"><hr><h4 id="_3-生成随机的-rgb-颜色值" tabindex="-1">3. 生成随机的 RGB 颜色值 <a class="header-anchor" href="#_3-生成随机的-rgb-颜色值" aria-label="Permalink to &quot;3. 生成随机的 RGB 颜色值&quot;">​</a></h4><p>​ <img src="'+x+'" alt="image-20230311234702281" style="zoom:67%;"></p><img src="'+q+'" alt="image-20230311234727543" style="zoom:67%;"><hr><h4 id="自定义组件-插槽" tabindex="-1">自定义组件 - 插槽 <a class="header-anchor" href="#自定义组件-插槽" aria-label="Permalink to &quot;自定义组件 - 插槽&quot;">​</a></h4><h4 id="_1-什么是插槽" tabindex="-1">1. 什么是插槽 <a class="header-anchor" href="#_1-什么是插槽" aria-label="Permalink to &quot;1. 什么是插槽&quot;">​</a></h4><p>​ 在自定义组件的 wxml 结构中，可以提供一个 slot 节点（插槽），用于承载组件使用者提供的 wxml 结构。</p><img src="'+f+'" alt="image-20230311234818924" style="zoom:67%;"><hr><h4 id="_2-单个插槽" tabindex="-1">2. 单个插槽 <a class="header-anchor" href="#_2-单个插槽" aria-label="Permalink to &quot;2. 单个插槽&quot;">​</a></h4><p>​ 在小程序中，默认每个自定义组件中只允许使用一个 slot 进行占位，这种个数上的限制叫做单个插槽。</p><img src="'+w+'" alt="image-20230311234909688" style="zoom:67%;"><hr><h4 id="_3-启用多个插槽" tabindex="-1">3. 启用多个插槽 <a class="header-anchor" href="#_3-启用多个插槽" aria-label="Permalink to &quot;3. 启用多个插槽&quot;">​</a></h4><p>​ 在小程序的自定义组件中，需要使用多 slot 插槽时，可以在组件的 .js 文件中，通过如下方式进行启用。</p><img src="'+v+'" alt="image-20230311234958328" style="zoom:67%;"><hr><h4 id="_4-定义多个插槽" tabindex="-1">4. 定义多个插槽 <a class="header-anchor" href="#_4-定义多个插槽" aria-label="Permalink to &quot;4. 定义多个插槽&quot;">​</a></h4><p>​ 可以在组件的 .wxml 中使用多个 slot 标签，以不同的 name 来区分不同的插槽。示例代码如下：</p><p>​</p><img src="'+F+'" alt="image-20230311235049758" style="zoom:67%;"><hr><h4 id="_5-使用多个插槽" tabindex="-1">5. 使用多个插槽 <a class="header-anchor" href="#_5-使用多个插槽" aria-label="Permalink to &quot;5. 使用多个插槽&quot;">​</a></h4><p>​ 在使用带有多个插槽的自定义组件时，需要用 slot 属性来将节点插入到不同的 slot 标签中。示例代码如下：</p><img src="'+D+`" alt="image-20230311235154553" style="zoom:67%;"><p>实例代码：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 用户页面 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">my-test4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;before&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;这是通过插槽填充的内容&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;after&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;-----------&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">my-test4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 组件页面 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">slot</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;before&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;这里是组件的内部结构&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">slot</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;after&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><hr><h4 id="自定义组件-父子组件之间的通信" tabindex="-1">自定义组件 - 父子组件之间的通信 <a class="header-anchor" href="#自定义组件-父子组件之间的通信" aria-label="Permalink to &quot;自定义组件 - 父子组件之间的通信&quot;">​</a></h4><h4 id="_1-父子组件之间通信的-3-种方式" tabindex="-1">1. 父子组件之间通信的 3 种方式 <a class="header-anchor" href="#_1-父子组件之间通信的-3-种方式" aria-label="Permalink to &quot;1. 父子组件之间通信的 3 种方式&quot;">​</a></h4><p>​ ①属性绑定</p><p>​ 用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容的数据</p><p>​ ②事件绑定</p><p>​ 用于子组件向父组件传递数据，可以传递任意数据</p><p>​ ③获取组件实例</p><p>​ 父组件还可以通过 this.selectComponent() 获取子组件实例对象</p><p>​ 这样就可以直接访问子组件的任意数据和方法</p><hr><h4 id="_2-属性绑定" tabindex="-1">2. 属性绑定 <a class="header-anchor" href="#_2-属性绑定" aria-label="Permalink to &quot;2. 属性绑定&quot;">​</a></h4><p>​</p><p>​ 属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。父组件的示例代码如下：</p><img src="`+P+'" alt="image-20230311235349496" style="zoom:67%;"><p>​ 子组件在 properties 节点中声明对应的属性并使用。示例代码如下：</p><img src="'+C+'" alt="image-20230311235428364" style="zoom:67%;"><hr><h4 id="_3-事件绑定" tabindex="-1">3. 事件绑定 <a class="header-anchor" href="#_3-事件绑定" aria-label="Permalink to &quot;3. 事件绑定&quot;">​</a></h4><p>​ 事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下：</p><p>​ ①在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件</p><p>​ ②在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件</p><p>​ ③在子组件的 js 中，通过调用 this.triggerEvent(&#39;自定义事件名称&#39;, { /* 参数对象 */ }) ，将数据发送到父组件</p><p>​ ④在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据</p><p>​ 步骤1：在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件。</p><p>​ <img src="'+I+'" alt="image-20230311235559470" style="zoom:67%;"></p><p>​ 步骤2：在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件。</p><img src="'+z+'" alt="image-20230311235639242" style="zoom:67%;"><p>​ 步骤3：在子组件的 js 中，通过调用 this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ }) ，将数据发送到父组件。</p><p>​ <img src="'+j+'" alt="image-20230311235751136" style="zoom:67%;"></p><p>​ 步骤4：在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据。</p><img src="'+O+'" alt="image-20230311235826839" style="zoom:67%;"><hr><h4 id="_4-获取组件实例" tabindex="-1">4. 获取组件实例 <a class="header-anchor" href="#_4-获取组件实例" aria-label="Permalink to &quot;4. 获取组件实例&quot;">​</a></h4><p>​ 可在父组件里调用 this.selectComponent(&quot;id或class选择器&quot;) ，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 this.selectComponent(&quot;.my-component&quot;)。</p><p>​ <img src="'+S+'" alt="image-20230311235910653" style="zoom:67%;"></p><hr><h4 id="自定义组件-behaviors" tabindex="-1">自定义组件 - behaviors <a class="header-anchor" href="#自定义组件-behaviors" aria-label="Permalink to &quot;自定义组件 - behaviors&quot;">​</a></h4><h4 id="_1-什么是-behaviors" tabindex="-1">1. 什么是 behaviors <a class="header-anchor" href="#_1-什么是-behaviors" aria-label="Permalink to &quot;1. 什么是 behaviors&quot;">​</a></h4><p>​ behaviors 是小程序中，用于实现组件间代码共享的特性，类似于 Vue.js 中的 “mixins”。</p><img src="'+G+'" alt="image-20230312000008030" style="zoom:67%;"><hr><h4 id="_2-behaviors-的工作方式" tabindex="-1">2. behaviors 的工作方式 <a class="header-anchor" href="#_2-behaviors-的工作方式" aria-label="Permalink to &quot;2. behaviors 的工作方式&quot;">​</a></h4><p>​ 每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中。</p><p>​ 每个组件可以引用多个 behavior，behavior 也可以引用其它 behavior。</p><hr><h4 id="_3-创建-behavior" tabindex="-1">3. 创建 behavior <a class="header-anchor" href="#_3-创建-behavior" aria-label="Permalink to &quot;3. 创建 behavior&quot;">​</a></h4><p>​ 调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用：</p><img src="'+R+'" alt="image-20230312000133626" style="zoom:67%;"><hr><h4 id="_4-导入并使用-behavior" tabindex="-1">4. 导入并使用 behavior <a class="header-anchor" href="#_4-导入并使用-behavior" aria-label="Permalink to &quot;4. 导入并使用 behavior&quot;">​</a></h4><p>​ 在组件中，使用 require() 方法导入需要的 behavior，挂载后即可访问 behavior 中的数据或方法，示例代码如下：</p><img src="'+L+'" alt="image-20230312000232753" style="zoom:67%;"><hr><h4 id="_5-behavior-中所有可用的节点" tabindex="-1">5. behavior 中所有可用的节点 <a class="header-anchor" href="#_5-behavior-中所有可用的节点" aria-label="Permalink to &quot;5. behavior 中所有可用的节点&quot;">​</a></h4><table tabindex="0"><thead><tr><th>可用的节点</th><th>类型</th><th>是否必填</th><th>描述</th></tr></thead><tbody><tr><td>properties</td><td>Object Map</td><td>否</td><td>同组件的属性</td></tr><tr><td>data</td><td>Object</td><td>否</td><td>同组件的数据</td></tr><tr><td>methods</td><td>Object</td><td>否</td><td>同自定义组件的方法</td></tr><tr><td>behaviors</td><td>String Array</td><td>否</td><td>引入其它的 behavior</td></tr><tr><td>created</td><td>Function</td><td>否</td><td>生命周期函数</td></tr><tr><td>attached</td><td>Function</td><td>否</td><td>生命周期函数</td></tr><tr><td>ready</td><td>Function</td><td>否</td><td>生命周期函数</td></tr><tr><td>moved</td><td>Function</td><td>否</td><td>生命周期函数</td></tr><tr><td>detached</td><td>Function</td><td>否</td><td>生命周期函数</td></tr></tbody></table><hr><h4 id="_6-同名字段的覆盖和组合规则" tabindex="-1">6. 同名字段的覆盖和组合规则/* <a class="header-anchor" href="#_6-同名字段的覆盖和组合规则" aria-label="Permalink to &quot;6. 同名字段的覆盖和组合规则/*&quot;">​</a></h4><p>​ 组件和它引用的 behavior 中可以包含同名的字段，此时可以参考如下 3 种同名时的处理规则：</p><p>​ ①同名的数据字段 (data)</p><p>​ ②同名的属性 (properties) 或方法 (methods)</p><p>​ ③同名的生命周期函数</p><p>​ 关于详细的覆盖和组合规则，大家可以参考微信小程序官方文档给出的说明：</p><p>​ <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" target="_blank" rel="noreferrer">https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html</a></p>',232)]))}const T=t(V,[["render",$]]);export{Q as __pageData,T as default};
