# 文法和语言

文法(上下文无关无法)G[<标识符>]：

```pascal
<标识符> —> <字母>	(重写规则(产生式))

<标识符> —> <标识符><数字>

<标识符> —> <标识符><字母>

<字母> —> a|b|c|......|z

<数字> —> 0|1|2|....|9
```



元语言符号：—> 和 ::= 表示定义为 。“|”表示或者

文法G定义为四元组(Vn,Vt,P,S)

​	Vn 非终结符集		Vt 终结符集		P产生式的集合(重写规则集合)		S识别符号，S∈Vn

Vn 非终结符：在文法中的左部出现

Vt 终结符：只在右部位终结符

P 重写规则集合：就是用花括号括起来的就是重写规则的集合，就是终结符和非终结符的集合，称为重写规则集合。

S 识别符号：第一条规则的左部，就是识别符号。

`Vn={<标识符>,<字母>,<数字>}`	`Vt={a,b,c,...z,0,1,2.....9}`		`P={<标识符>—><字母>}`

.......

`{  <数字>—> 0|1|2|.....|9 }`

S=<标识符>

Vn∩Vt=∅			V=Vn∩Vt

很多时候，不用将文法G的四元组显示地表示出来，而只将产生式写出。一般约定，第一条产生式的左部是识别符；用尖括号括起来的是非终结符，不用尖括号括起来的是终结符，或者用大写字母表示非终结符，小写字母表示终结符。另外，也有一种习惯写法，将G写成G[S]，其中S是识别符，例还可以写成：

​		G：S —> 0S1

​			   S —> 01

​	或

​		G[S]:	 S —> 0S1

​					 S —>  01

例：

v=233<字母>666

w=233a666		

<字母>::=(或—>) a

<img src="/compileImages/直接推到或直接产生.png" style="zoom:60%;" />

v=>w0	推导长度：n=1

v=w0	推导长度： n=0

多步推导
$$
V\frac{+}{=>} w \quad  n≥1
$$
广义推导
$$
V\frac{*}{=>} w \quad  n≥0
$$




# 符号和符号串

## 1、字母表：

元素的非空有限集，例：`∑={a、b、c}`

注意：

1. 字母表中至少包含一个元素
2. 字母表中的元素可以是字母、数字或其他符号
3. 在不同语言有不同的字母表
4. 任何语言的字母表指出了改语言中允许出现的一切符号

## 2、符号（字符）：

字母表中的元素成为符号。

例：字母表`∑={a、b、c}`中的a,b,c为符号

## 3、符号串：

符号串的有穷序列称为符号串。

例：字母表`∑={a、b、c}`，可组成的符号串有a,b,c,aa,ba,cba...

注意：

1. 符号串总是建立在某个特定字母表上的且只能由字母表上的有穷多个符号组成。

2. 符号串中符号的顺序是很重要的

3. 符号串的长度：符号串中所包含的符号的个数。

   例：s=lamstring，则|s|=9

4. 不包含任何符号的符号串，称为空符号串，用`ε`表示，即`|ε|`=0空串的长度为0

# 符号串的运算

1、符号串的连接

例：x=ab，y=vc，则xy=abvc

注意：对任意的符号串x，有x`ε`=`ε`x=x

如果和空串(`ε`)连接，都是它本身

2、符号串的幂运算

例：x=ab，则
$$
x^0=ε,x^1=ab,....
\\
x^2=abab
$$
3、集合的乘积

`AB={xy|x∈A且y∈B}`

例：`A={x,y,z} B={a,bc}`则AB=？

`{xya,xybc,za,zbc}`两个集合做乘积=集合

注意：

1. `ε`A=A`ε`=A
2. `{ε}`与`{}`的区别
3. `{ε}`表示由空符号串`ε`所组成的集合，`{ε}`基数是1，`{}`基数是0
4. `{}`表示空集合`Ф`

4、集合的幂运算

例：`A={x,y,z},`则
$$
A^0=\{ε\},A^1=A,A^2=AA,...
$$
5、集合A的正闭包
$$
A^+与闭包A^*
$$

$$
A^+=A^1∪A^2∪A^3∪...∪A^n...\\
A^*=A^0∪A^1∪A^2∪...∪A^n=\{ε\}∪A^+
$$

注意：
$$
A^*中一定要包含空符号串ε。
$$
<span style="color:red;">特点：集合的元素任意组合，组成的串都在闭包里。</span>

# 文法和语言的形式定义

<span style="color:#FDB238;">规则</span>也称<span style="color:#FDB238;">产生式</span>，它是一个符号与一个符号串的有序对`(A,β)`，通常写作A—>β

其中A是一个符号，β是符号串，—><span style="color:#FDB238;">表示定义为或生成</span>

例：

A—>0

A—>1

A—>A0

A—>A1

一组规则规定了一个语言的语法结构。

# 文法的定义

文法是产生式的非空有穷集合，通常表示成四元组
$$
G=(V_n,V_T,P,S)。其中：
$$

1. Vn是产生式中非终结符的集合
2. Vt是产生式中终结符的集合。Vn∩Vt=`∅`
3. P是文法规则的集合
4. S是非终结符，称为文法的开始符号，它至少要在一条规则的左部出现。由他开始，识别出我们所定义的语言。

规则中的符号分为两类：终结符号和非终结符号。

<span style="color:#CC0000;">非终结符</span>是出现在规则左部，能派生出符号或符号串的那些符号。(非终结符`Vn={E,T,F}`)

<span style="color:#CC0000;">终结符</span>是不属于非终结符的那些符号，它是组成语言的基本符号，终结符意味着替换的终止，它是一个语言中不可再分的基本符号。(终结符`Vt={+，*，(,),i}`)

例：

E—>E+T

E—>T

T—>T*F

T—>F

F—>(E)

F—>i

<span style="color:#EEB029;">约定</span>：第一条规则的左部是文法开始的符号，对文法不用四元式显示表示，而只写规则集合。

1. 直接推导

   G=(Vn,Vt,P,S)，其中v=α，A，γ，w=a，β，γ，A∈N

   a，β，γ∈(Vt∪Vn)*

   若A—>β∈P，则α，A，γ=>α，β，γ，即v=>w

   称为v直接推导出w(或v直接归约成w)

   例：

   E->E+T|T		<span style="color:red;">E->E+T		E—>T 2个产生式</span>

   T->T*F|F		<span style="color:red;">E=>E+T		（E->E+T依据）</span>

   F->(E)|i		  <span style="color:red;">=>E+T*F		（T->T\*F依据）</span>

   推导出E—>E+T*F的过程每一步都是直接推导

   直接推导长度为1	<span style="color:red;">利用产生式直接推出来</span>

   1. 简介推导(或推导)	<span style="color:red;">多步直接推导的结果就是推导</span>

<img src="/PythonImages/间接推导.png" style="zoom:60%;" />

# 句型和句子

句子句型<span style="color:red;">大前提：文法的开始符号可以推导的串。</span>

<img src="/PythonImages/句子和句型.png" style="zoom:60%;" />

G[Z]	V(字汇表)
$$
如果z\quad V\frac{*}{=>}x,x∈V^*,称为句型
$$

$$
如果z\quad V\frac{*}{=>}x,x∈Vt^*(终结符),称为句子
$$

文法描述的语言是该文法一切句子的集合
$$
L(G)=\{x|s^*=>,且x∈Vt^*\}
$$

# 递归规则(右部出现左部)

递归：自己加自己，在加一个终结符

![](/public/compileImages/文法和语言.png)

若L(G1)=L(G2)，则等价

**成对符号递归：**可用下述产生式表示成对符号递归：

例：

```pascal
A->aAβ|ab
A=>aβ
A=>aAβ->aaββ
A=>aaAββ=》aaaβββ
```

$$
\{a^nβ^n|n≥1\}
$$

对于一个给定的语言，描述改语言的文法不一定唯一，给定一个文法G，就能唯一地确定其语言L(G)

# 乔姆斯基(`chomsky`)的语言分类法

0型文法(称为短语结构文法)		1型文法(上下文敏感或上下文有关文法)

2型文法(上下文无关无法)

对于某文法G，P中的每个规则具有下列形式
$$
α->β，其中α∈Vn(非终结符)，β∈V^*(字汇表)
$$
3型文法(正规文法)：要么定义成一个终结符，要么定义成一个非终结符`*`终结符

对于某文法G，P中的每个规则具有下列形式

```pascal
A::=a
或
A::=ab(右线性文法)
A::=a
或
A::=Ba(左线性文法)
```

# 语法分析树(指导树)

设有文法 G[S]:

```pascal
S->aAB
A->Ba|a
B->bd
```

<img src="/compileImages/语法分析树.png" style="zoom:60%;" />

```pascal
S=>aAb=>aBaB=>abdaB=>abdabd
```

最左推导：每步直接推导总是替换最左的非终结符

最右推导(规范推导、最右规约)：

```pascal
S=>aAB
=>aAbd
=>aBabd
=>abdabd
```

归约序列：

```pascal
abdabd=>aBabd
=>aAbd
=>aAB
=>S(最左归约，规范归约)
```

规范句型(右句型)从右向左归约或推导称为右句型

# 二义性(句子、文法、语言)

```pascal
G[E]:
	E->E+E|E*E|(E)|i
```

推导1

```pascal
E=>E+E
=>E*E+E
=>i*E+E
=>i*i+E
=>i*i+i
```

推导2

```pascal
E=>E*E
=>i*E
=>i*E+E
=>i*i+E
=>i*i+i
```

推导树1：

<img src="/compileImages/推导1的语法树.png" style="zoom:67%;" />

推导树2：

<img src="/compileImages/推导2的语法树.png" style="zoom:60%;" />

<span style="color:red;font-size:20px;">定义这个句子具有二义性！</span>

如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的。

# 句子的分析

语法树是句型推导过程的几何表示。

句型的分析就是识别一个符号串是否为某文法的句型，是某个推导的构造过程。进一步说，当给定一个符号串时，试图按照某文法的规则为该符号串构造推导或语法树，以此识别出它是该文法的一个句型；当符号串全部由终结符号组成时，就是识别它是不是某文法的句子。因此也有人把语法树称为**语法分析树**或**语法树**。在语言的编译实现中，把完型句型分析的程序称为**分析程序**或**识别程序**

"<span style="font-size:23px;">**分析**</span>"即总是从左到右地识别输入字符串，这种分析算法又可分成两大类，即自顶向下的和自底向上的。所谓由自顶向下分析法，是从文法的开始符号出发，反复使用各种产生式，寻找"匹配"于输入符号串的推导。自底向上的方法则是从输入符号串开始，逐步进行"归纳"，直至归约到文法的开始符号。

自顶向下的分析方法(构造推导)

<img src="/compileImages/自顶向下1.png" style="zoom:67%;" />

<img src="/compileImages/自顶向下2.png" style="zoom:67%;" />

自底向上的分析方法(构造归约)

```pascal
x=>...=>识别符号
```

<img src="/compileImages/自底向上.png" style="zoom:60%;" />

<img src="/compileImages/自底向上2.png" style="zoom:60%;" />

**子树的末端结点符号串相对于树根的<span style="font-size:20px;">短语</span>。**

**简单子树的末端结点组成的符号串是相对于简单树根的<span style="font-size:20px;">简单短语</span>。**

**最左简单子树的末端结点组成的符号串时<span style="font-size:20px;">句柄</span>。**

<img src="/compileImages/句柄、短语、简单短语.png" style="zoom:60%;" />

短语就是一个子树的末端点。

(直接短语)简单短语是末尾的终结符。

句柄是最左侧末尾结点，只适用最右推导才会用到，其他的用不了。

例：求句型 `abdabd` 的短语，简单短语，句柄

<img src="/compileImages/例题.png" style="zoom:60%;" />

`abdabd` 是 `abdabd`相对于 S 的短语

`bda` 是 `abdabd`相对于 A 的短语

`bd` 是 `abdabd`相对于 B 的短语 

`bd` 是句型 `abdabd` 相对于 B 的简单短语

句柄是 `bd`

# 正规文法 (**3**型文法)

$$
(左线性)P:U->t 或 U->Wt其中U、W∈V_n t∈V_t
\\
(右线性)P:U->t 或 U—>tW其中U、W∈V_t t∈V_t
$$

$$
正规文法描述的是V_t(句子)上的正规集
\\
例：(左线性文法)\\
Z->U0 | V1
\\
U->Z1 | 1
V->Z0 | 0
$$

3型文法描述的是单词的构成规则

## 单词的形式化描述工具

<img src="/compileImages/1.png" style="zoom:60%;" />

<img src="/compileImages/2.png" style="zoom:60%;" />

正规文法U→tU|t 对应的语言`{tnt|n≥0}`

正规式：t*t        

正规集：`{t,tt,ttt....}`

例：

设有正规文法

```pascal
Z->OA
A->OA|OB
B->A|ε
正规式:
A=OA+O(1A+ε)
=OA+O1A+O
A=(O+O)A+O
A->(O101)A|O
A->xA1y x*y
```

正规式转换为正规文法两种类型

```pascal
ab型转化为：A→aB 和 B→b
a*b型转化为： A→aA|b

A→ab       A→aB和B→b
右部长度是2转化为终结符+非终结符、终结符。
正规文法要求右部长度≤2
```

正规式和正规文法的作用是描述单词的构成规则

# 有穷自动机(`NFA`和`DFA`)

**有限自动机(有穷自动机)：**是单词符号的自动识别机器，其能准确识别

**正规文法**定义的语言和**正规表达式**的集合

有限自动机可分为**两类**：

1. 确定的有穷自动机(`DFA`)
2. 非确定的有穷自动机(`NFA`)

## 确定的有穷自动机(`DFA`)

<img src="/compileImages/DFA.png" style="zoom:80%;" />

<img src="/compileImages/DFA有穷自动机.png" alt="image-20240925173212619" style="zoom:67%;" />

## 非确定的有穷自动机(`NFA`)

<img src="/compileImages/NFA.png" style="zoom:60%;" />

<img src="/compileImages/不确定有穷自动机.png" style="zoom:60%;" />

`DFA（不确定有穷自动机）`有三种形式：

1. 数学定义(五元组形式)：严密
2. 状态转移图：直观
3. 状态转换矩阵：面向编程

<img src="/compileImages/确定有穷自动机(DFA).png" style="zoom:60%;" />

<img src="/compileImages/状态图.png" style="zoom:60%;" />

<img src="/compileImages/状态转移矩阵.png" style="zoom:60%;" />

### `NFA`(有穷自动机)与`DFA`(不确定有穷自动机)的区别:

<img src="/compileImages/NFA和DFA的区别.png" style="zoom:60%;" />

## `NFA` 转化 `DFA`  公式

![](/compileImages/DFA和NFA的区别.jpg)

详细教程请参考[编译原理正规表达式转NFA到DFA再化简_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1mh41187fN/?spm_id_from=333.337.search-card.all.click&vd_source=5f89827431c7b3b5ef45263e3be6eb43)

